<script lang="ts">
  import { onMount, onDestroy, createEventDispatcher } from 'svelte';
  import { FaceMesh } from '@mediapipe/face_mesh/face_mesh';
  import {
    drawConnectors,
    FACEMESH_TESSELATION,
    FACEMESH_RIGHT_EYE,
    FACEMESH_LEFT_EYE,
    FACEMESH_FACE_OVAL,
    FACEMESH_LIPS,
  } from '@mediapipe/drawing_utils/drawing_utils';
  import {
    PoseGuidanceDirection,
    PoseGuidanceType,
    POSE_GUIDANCE_MAP,
    type PoseGuidanceData,
  } from '../../../types/camera';
  import {
    ExpressionAnalyzer,
    type ExpressionData,
  } from '../../../lib/ExpressionAnalyzer';
  import {
    cameraConfig,
    poseTolerances,
    faceQualityThresholds,
    detectionTimingSettings,
    poseCalculationConfig,
    mediaPipeConfig,
  } from '../../../stores/cameraConfig';
  import { getDevicePitchAdjustment } from '../../../domain/cameraConfig';
  import type { CameraConfiguration } from '../../../domain/cameraConfig';
  import { MediaPipeAssetManager } from '../../../lib/MediaPipeAssetManager';

  const dispatch = createEventDispatcher();

  // Props
  export let videoElement: HTMLVideoElement | undefined = undefined;
  export let canvasElement: HTMLCanvasElement | undefined = undefined;
  export let showMesh: boolean = true;
  export let currentMode: string = 'idle';
  // mirrorMode „ÅØ‰ΩøÁî®„Åó„Å™„ÅÑ„Åü„ÇÅÂâäÈô§

  // Constants
  export const CAPTURE_COUNT: number = 1;
  export let CaptureMode: any;
  export let enableExpressionDetection: boolean | undefined = undefined;

  // MediaPipe instances
  let faceMesh: any;
  let camera: any;
  let canvasCtx: CanvasRenderingContext2D | null = null;

  // Initialization state management
  let isStartingCamera = false;
  let isMediaPipeReady = false;
  let isCameraConfigReady = false;
  let isMediaPipeFullyInitialized = false;
  let hasProcessedFirstFrame = false;
  let initializationStep = 'idle'; // 'idle' | 'config' | 'mediapipe' | 'camera' | 'processing' | 'ready' | 'error'

  // Face detection state
  let faceDetectionCount = 0;
  let faceDetected = false;
  let faceDetectionStartTime: number | null = null;
  let faceLandmarks: any = null;

  // Expression analysis
  let expressionAnalyzer = new ExpressionAnalyzer();
  let currentExpression: ExpressionData | null = null;

  // Video dimensions for accurate coordinate transformation
  let currentVideoWidth = 0;
  let currentVideoHeight = 0;

  // Configuration from API (reactive)
  let config: CameraConfiguration;
  let FACE_DETECTION_THRESHOLD: number;
  let FACE_DETECTION_DELAY: number;
  let THRESHOLDS: { roll: number; pitch: number; yaw: number };
  let MIN_FACE_SIZE: number;
  let MIN_FACE_QUALITY: number;
  let GUIDANCE_UPDATE_INTERVAL: number;

  // Subscribe to camera configuration
  $: config = $cameraConfig.config;
  $: FACE_DETECTION_THRESHOLD =
    config.detectionTimingSettings.stabilityFrameCount;
  $: FACE_DETECTION_DELAY =
    config.detectionTimingSettings.autoCaptureDelaySeconds;
  $: THRESHOLDS = {
    roll: config.poseTolerances.rollDegrees,
    pitch: config.poseTolerances.pitchDegrees,
    yaw: config.poseTolerances.yawDegrees,
  };
  $: MIN_FACE_SIZE = config.faceQualityThresholds.minRelativeSize;
  $: MIN_FACE_QUALITY = config.faceQualityThresholds.minQualityScore;
  $: GUIDANCE_UPDATE_INTERVAL =
    config.detectionTimingSettings.guidanceUpdateIntervalMs;

  // Pose and stability tracking
  let stablePosition = false;
  let stableStartTime: number | null = null;
  let stableFrameCount = 0;
  let progress = 0;

  // Guidance
  let poseGuidanceMessage = '';
  let poseGuidanceType = '';
  let showPoseGuidance = false;
  let lastGuidanceUpdate = 0;
  let lastGuidanceMessage = '';

  // MediaPipe„Ç¢„Çª„ÉÉ„Éà„Éû„Éç„Éº„Ç∏„É£„Éº
  let assetManager: MediaPipeAssetManager;
  let localBlobUrls: string[] = []; // ‰ΩúÊàê„Åó„ÅüBlob URL„ÇíÁÆ°ÁêÜ
  let preloadedUrls: Map<string, string> = new Map(); // ‰∫ãÂâçÊ∫ñÂÇô„Åó„ÅüURL

  onMount(async () => {
    try {
      initializationStep = 'config';

      // „Ç¢„Çª„ÉÉ„Éà„Éû„Éç„Éº„Ç∏„É£„Éº„ÇíÂàùÊúüÂåñ
      assetManager = new MediaPipeAssetManager();
      await assetManager.init();

      // MediaPipe„Ç¢„Çª„ÉÉ„Éà„ÅÆURL„Çí‰∫ãÂâçÊ∫ñÂÇô
      await prepareMediaPipeAssets();

      // Ensure camera configuration is loaded first
      if (!$cameraConfig.isLoaded) {
        console.log('üìä „Ç´„É°„É©Ë®≠ÂÆö„ÇíË™≠„ÅøËæº„Åø‰∏≠...');
        await cameraConfig.loadConfig();
        console.log('‚úÖ „Ç´„É°„É©Ë®≠ÂÆö„ÅÆË™≠„ÅøËæº„ÅøÂÆå‰∫Ü');
      }
      isCameraConfigReady = true;

      // Pre-initialize MediaPipe in background (don't wait for user action)
      initializationStep = 'mediapipe';
      console.log('üîß MediaPipe„ÅÆ‰∫ãÂâçÂàùÊúüÂåñ„ÇíÈñãÂßã...');
      await initializeMediaPipe();
      isMediaPipeReady = true;
      initializationStep = 'ready';
      console.log('‚úÖ MediaPipe„ÅÆ‰∫ãÂâçÂàùÊúüÂåñÂÆå‰∫ÜÔºà„Ç´„É°„É©Ëµ∑ÂãïÂæÖÊ©ü‰∏≠Ôºâ');
    } catch (error) {
      initializationStep = 'error';
      console.error('‚ùå MediaPipe„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      dispatch('error', {
        message:
          '„Ç´„É°„É©„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Éö„Éº„Ç∏„Çí„É™„É≠„Éº„Éâ„Åó„Å¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
      });
    }
  });

  // Public method to reset detection state
  export function resetDetectionState() {
    // Reset all detection-related variables
    stablePosition = false;
    stableFrameCount = 0;
    lastGuidanceUpdate = 0;
    showPoseGuidance = false;
    poseGuidanceMessage = '';
    poseGuidanceType = '';

    // Reset expression analysis (only if enabled)
    if (enableExpressionDetection === true) {
      expressionAnalyzer.resetCalibration();
    }
    currentExpression = null;
  }

  onDestroy(() => {
    // Blob URL„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    localBlobUrls.forEach(url => URL.revokeObjectURL(url));
    localBlobUrls = [];
    preloadedUrls.clear();

    completeCleanup();
  });

  // Remove automatic camera starting - now controlled externally

  // Watch for mode changes (debug disabled)
  // $: if (currentMode) { console.log('üì± Mode changed:', currentMode); }

  // MediaPipe„Ç¢„Çª„ÉÉ„Éà„ÅÆURL„Çí‰∫ãÂâçÊ∫ñÂÇô
  async function prepareMediaPipeAssets() {
    // MediaPipe„ÅåÂÆüÈöõ„Å´Ë™≠„ÅøËæº„ÇÄ„Éï„Ç°„Ç§„É´„Çí„Åô„Åπ„Å¶Âê´„ÇÅ„Çã
    const requiredFiles = [
      'face_mesh_solution_packed_assets.data',
      'face_mesh_solution_simd_wasm_bin.wasm',
      'face_mesh_solution_packed_assets_loader.js',
      'face_mesh_solution_simd_wasm_bin.js', // loader„Çπ„ÇØ„É™„Éó„Éà
      'face_mesh.binarypb', // „É¢„Éá„É´„Éá„Éº„Çø
    ];

    console.log('üîß MediaPipe„Ç¢„Çª„ÉÉ„Éà„ÅÆ‰∫ãÂâçÊ∫ñÂÇô„ÇíÈñãÂßã...');

    for (const file of requiredFiles) {
      try {
        // „Åæ„Åö„É≠„Éº„Ç´„É´„Ç≠„É£„ÉÉ„Ç∑„É•„ÇíÁ¢∫Ë™ç
        let localUrl = await assetManager.createLocalFileUrl(file);

        if (localUrl) {
          console.log(`üéØ „É≠„Éº„Ç´„É´„Ç≠„É£„ÉÉ„Ç∑„É•„Åã„Çâ‰∫ãÂâçÊ∫ñÂÇô: ${file}`);
          preloadedUrls.set(file, localUrl);
          localBlobUrls.push(localUrl);
        } else {
          // „Ç≠„É£„ÉÉ„Ç∑„É•„Åå„Å™„ÅÑÂ†¥Âêà„ÄÅCDN„Åã„ÇâÁõ¥Êé•„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Å¶Blob URL„Çí‰ΩúÊàê
          console.log(`üì• CDN„Åã„Çâ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ‰∏≠: ${file}`);
          const cdnUrl = `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;

          try {
            const response = await fetch(cdnUrl);
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }

            const data = await response.arrayBuffer();
            console.log(
              `‚úÖ „ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÂÆå‰∫Ü: ${file} (${Math.round(data.byteLength / 1024)}KB)`
            );

            // Blob URL„Çí‰ΩúÊàê
            const mimeType = file.endsWith('.wasm')
              ? 'application/wasm'
              : file.endsWith('.js')
                ? 'application/javascript'
                : 'application/octet-stream';
            const blob = new Blob([data], { type: mimeType });
            const blobUrl = URL.createObjectURL(blob);

            preloadedUrls.set(file, blobUrl);
            localBlobUrls.push(blobUrl);

            // „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßIndexedDB„Å´„ÇÇ‰øùÂ≠òÔºàÊ¨°ÂõûÁî®Ôºâ
            assetManager.saveAsset(file, data).catch(err => {
              console.warn(
                `IndexedDB„Å∏„ÅÆ‰øùÂ≠ò„Å´Â§±ÊïóÔºàÊ¨°Âõû„ÅØCDN„Åã„ÇâÂÜçÂèñÂæó„Åó„Åæ„ÅôÔºâ: ${file}`,
                err
              );
            });
          } catch (downloadError) {
            console.error(
              `‚ùå CDN„Åã„Çâ„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å´Â§±Êïó: ${file}`,
              downloadError
            );
            // ÊúÄÂæå„ÅÆÊâãÊÆµ„Å®„Åó„Å¶CDN URL„ÇíÁõ¥Êé•‰ΩøÁî®ÔºàMediaPipe„Å´‰ªª„Åõ„ÇãÔºâ
            console.warn(
              `‚ö†Ô∏è „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: MediaPipe„Å´Áõ¥Êé•CDN„Åã„ÇâË™≠„ÅøËæº„Åæ„Åõ„Åæ„Åô`
            );
            preloadedUrls.set(file, cdnUrl);
          }
        }
      } catch (error) {
        console.error(`„Ç¢„Çª„ÉÉ„ÉàÊ∫ñÂÇô„Ç®„É©„Éº: ${file}`, error);
        // „Ç®„É©„ÉºÊôÇ„ÅØCDN URL„Çí„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
        preloadedUrls.set(
          file,
          `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        );
      }
    }

    console.log('‚úÖ MediaPipe„Ç¢„Çª„ÉÉ„Éà„ÅÆ‰∫ãÂâçÊ∫ñÂÇôÂÆå‰∫Ü');
  }

  async function initializeMediaPipe() {
    try {
      faceMesh = new FaceMesh({
        locateFile: (file: string) => {
          // ‰∫ãÂâçÊ∫ñÂÇô„Åó„ÅüURL„ÇíÂêåÊúüÁöÑ„Å´Ëøî„Åô
          const url =
            preloadedUrls.get(file) ||
            `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
          console.log(
            `üìÅ MediaPipe„Éï„Ç°„Ç§„É´Êèê‰æõ: ${file} -> ${url.substring(0, 50)}...`
          );
          return url;
        },
      });

      // Use settings from API configuration
      const mediaPipeSettings = config.mediaPipeConfig;
      faceMesh.setOptions({
        maxNumFaces: mediaPipeSettings.maxDetectedFaces,
        refineLandmarks: mediaPipeSettings.enableRefinedLandmarks,
        minDetectionConfidence: mediaPipeSettings.minDetectionConfidence,
        minTrackingConfidence: mediaPipeSettings.minTrackingConfidence,
        selfieMode: mediaPipeSettings.selfieMode,
        staticImageMode: mediaPipeSettings.staticImageMode,
      });

      faceMesh.onResults(onResults);
      console.log('‚úÖ FaceMeshË®≠ÂÆöÂÆå‰∫Ü„ÄÅonResults„Ç≥„Éº„É´„Éê„ÉÉ„ÇØÁôªÈå≤ÂÆå‰∫Ü');
    } catch (error) {
      console.error('‚ùå MediaPipeÂàùÊúüÂåñ„Ç®„É©„Éº:', error);
      throw error;
    }
  }

  // „Ç≠„É£„É≥„Éê„ÇπÂêåÊúüÊ©üËÉΩ„ÅØÂâäÈô§

  async function startCamera() {
    // Check initialization readiness
    if (
      !isMediaPipeReady ||
      !isCameraConfigReady ||
      initializationStep !== 'ready'
    ) {
      console.log('‚è≥ „Ç´„É°„É©„ÅÆÊ∫ñÂÇô„Åå„Åæ„Å†ÂÆå‰∫Ü„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì');
      return;
    }

    if (!videoElement || !faceMesh) {
      console.log('‚ùå ÂøÖË¶Å„Å™„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
      return;
    }

    if (isStartingCamera) {
      console.log('‚è≥ „Ç´„É°„É©Ëµ∑ÂãïÂá¶ÁêÜ„ÅåÊó¢„Å´ÂÆüË°å‰∏≠„Åß„Åô');
      return;
    }

    initializationStep = 'camera';
    isStartingCamera = true;
    console.log('üì∑ „Ç´„É°„É©Ëµ∑Âãï„ÇíÈñãÂßã„Åó„Åæ„Åô');
    try {
      // MediaPipe Camera utils„Çí‰Ωø„Çè„Åö„Å´Áã¨Ëá™„Åß„Ç´„É°„É©„ÇíÂà∂Âæ°
      // „Çπ„Éû„ÉõÂêë„Åë„Å´Á∏¶Âêë„Åç„ÅÆ„Ç´„É°„É©„Çπ„Éà„É™„Éº„É†„ÇíÂèñÂæó
      const isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);
      const isPortrait = window.innerHeight > window.innerWidth;

      let constraints: MediaStreamConstraints | undefined;
      let finalStream: MediaStream;

      // „Çπ„Éû„ÉõÁ∏¶Âêë„Åç„ÅÆÂ†¥Âêà„ÄÅË§áÊï∞„ÅÆËß£ÂÉèÂ∫¶„ÇíË©¶„Åô
      if (isMobile && isPortrait) {
        // Âà©Áî®ÂèØËÉΩ„Å™ÂÖ®Ëß£ÂÉèÂ∫¶„ÇíÂèñÂæó„Åó„Å¶Á∏¶Âêë„Åç„ÇíÊé¢„Åô
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(
            device => device.kind === 'videoinput'
          );
          console.log('üì± Available video devices:', videoDevices.length);

          // „Åæ„Åö„ÅØÂà∂Á¥Ñ„Å™„Åó„Åß„Ç´„É°„É©ËÉΩÂäõ„ÇíÁ¢∫Ë™ç
          const testStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'user' },
          });
          const testTrack = testStream.getVideoTracks()[0];
          const capabilities = testTrack.getCapabilities();
          testStream.getTracks().forEach(track => track.stop());

          console.log('üì∑ Camera capabilities:', capabilities);

          // Âà©Áî®ÂèØËÉΩ„Å™Ëß£ÂÉèÂ∫¶„Åã„ÇâÁ∏¶Âêë„Åç„ÇíÂÑ™ÂÖàÁöÑ„Å´ÈÅ∏Êäû
          const availableResolutions = [];
          if (capabilities.width && capabilities.height) {
            const maxWidth = capabilities.width.max || 1920;
            const maxHeight = capabilities.height.max || 1080;
            console.log(`üìè Max resolution: ${maxWidth}x${maxHeight}`);

            // Á∏¶Âêë„ÅçËß£ÂÉèÂ∫¶„ÅÆ„Éë„Çø„Éº„É≥„ÇíÁîüÊàê
            if (maxHeight >= maxWidth) {
              // „Åô„Åß„Å´Á∏¶Èï∑„ÅÆÂ†¥Âêà
              availableResolutions.push({ width: maxWidth, height: maxHeight });
            } else {
              // Ê®™Èï∑„ÅÆÂ†¥Âêà„ÄÅÁ∏¶Ê®™„ÇíÂÖ•„ÇåÊõø„Åà„Å¶Á∏¶Âêë„Åç„Å´„Åô„Çã
              availableResolutions.push({ width: maxHeight, height: maxWidth });
              availableResolutions.push({ width: maxWidth, height: maxHeight });
            }
          }
        } catch (e) {
          console.log('‚ùå Failed to get capabilities:', e);
        }

        // ÁîªÈù¢„Çµ„Ç§„Ç∫„Åã„ÇâÂãïÁöÑ„Å´resolutionPatterns„ÇíË®àÁÆó
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const screenAspectRatio = screenWidth / screenHeight;

        console.log('üì± Screen info for resolution calculation:', {
          screenWidth,
          screenHeight,
          screenAspectRatio: screenAspectRatio.toFixed(3),
        });

        // „Çπ„Éû„Éõ„Ç´„É°„É©„Å´ÈÅ©„Åó„ÅüËß£ÂÉèÂ∫¶„Éë„Çø„Éº„É≥„ÇíÁîüÊàêÔºàÁ∏¶Èï∑„Åß„ÇÇÊ®™Èï∑Ëß£ÂÉèÂ∫¶„Çí‰ΩøÁî®Ôºâ
        const resolutionPatterns = [
          // È´òËß£ÂÉèÂ∫¶ÔºàÊ≠£ÊñπÂΩ¢„Å´Ëøë„ÅÑÔºâ
          { width: 1080, height: 1080, aspectRatio: 1.0 },
          { width: 960, height: 1280, aspectRatio: 0.75 }, // 3:4
          { width: 720, height: 960, aspectRatio: 0.75 }, // 3:4
          // 4:3Ôºà„Ç´„É°„É©„ÅÆÊ®ôÊ∫ñÔºâ
          { width: 960, height: 720, aspectRatio: 4 / 3 },
          { width: 640, height: 480, aspectRatio: 4 / 3 },
          // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®
          { width: 480, height: 640, aspectRatio: 0.75 },
          { width: 360, height: 480, aspectRatio: 0.75 },
        ];

        console.log('üì± Generated resolution patterns:', resolutionPatterns);

        let stream = null;
        let successfulPattern = null;

        for (const pattern of resolutionPatterns) {
          try {
            constraints = {
              video: {
                facingMode: 'user',
                width: { ideal: pattern.width },
                height: { ideal: pattern.height },
                aspectRatio: { ideal: pattern.aspectRatio },
                // exact„ÇÑmin/max„ÇíÂâäÈô§„Åó„Å¶Âà∂Á¥Ñ„ÇíÁ∑©Âíå
              },
              audio: false,
            };

            console.log(
              `üì± Trying resolution: ${pattern.width}x${pattern.height}`
            );
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            successfulPattern = pattern;
            console.log(
              `‚úÖ Successfully got stream with: ${pattern.width}x${pattern.height}`
            );
            break;
          } catch (e) {
            console.log(
              `‚ùå Failed with ${pattern.width}x${pattern.height}:`,
              (e as Error).message
            );
          }
        }

        if (!stream) {
          // ÁâπÂÆö„ÅÆ„Éá„Éê„Ç§„ÇπID„ÇíÊåáÂÆö„Åó„Å¶Ë©¶„Åô
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(
            device => device.kind === 'videoinput'
          );
          console.log(
            'üì± Trying specific camera devices:',
            videoDevices.length
          );

          for (const device of videoDevices) {
            console.log(`üì∑ Trying device: ${device.label || device.deviceId}`);
            for (const pattern of resolutionPatterns) {
              try {
                constraints = {
                  video: {
                    deviceId: { exact: device.deviceId },
                    width: { ideal: pattern.width },
                    height: { ideal: pattern.height },
                    aspectRatio: { ideal: pattern.aspectRatio },
                  },
                  audio: false,
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                successfulPattern = pattern;
                console.log(
                  `‚úÖ Success with device ${device.label} at ${pattern.width}x${pattern.height}`
                );
                break;
              } catch (e) {
                // Ê¨°„ÅÆ„Éë„Çø„Éº„É≥„ÇíË©¶„Åô
              }
            }
            if (stream) break;
          }
        }

        if (!stream) {
          // ÊúÄÂæå„ÅÆÊâãÊÆµÔºöÊÆµÈöéÁöÑ„Å´Âà∂Á¥Ñ„ÇíÁ∑©Âíå
          console.log(
            'üì± „Åô„Åπ„Å¶„ÅÆËß£ÂÉèÂ∫¶„ÅßÂ§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÂà∂Á¥Ñ„ÇíÁ∑©Âíå„Åó„Å¶„É™„Éà„É©„Ç§„Åó„Åæ„Åô'
          );

          const fallbackPatterns = [
            // ÊÆµÈöé1: „Éï„É≠„É≥„Éà„Ç´„É°„É©„ÅÆ„ÅøÊåáÂÆö
            { video: { facingMode: 'user' }, audio: false },
            // ÊÆµÈöé2: ‰ªªÊÑè„ÅÆ„Ç´„É°„É©
            { video: true, audio: false },
            // ÊÆµÈöé3: ÊúÄÂ∞èÂà∂Á¥Ñ
            { video: {}, audio: false },
          ];

          for (const fallback of fallbackPatterns) {
            try {
              console.log('üì± „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂà∂Á¥Ñ„Åß„É™„Éà„É©„Ç§‰∏≠...');
              stream = await navigator.mediaDevices.getUserMedia(fallback);
              console.log('‚úÖ „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂà∂Á¥Ñ„ÅßÊàêÂäü');
              break;
            } catch (e) {
              console.log('‚ùå „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂà∂Á¥Ñ„ÇÇÂ§±Êïó');
              continue;
            }
          }

          if (!stream) {
            throw new Error('„Åô„Åπ„Å¶„ÅÆ„Ç´„É°„É©Âà∂Á¥Ñ„ÅßÂ§±Êïó„Åó„Åæ„Åó„Åü');
          }
        }

        finalStream = stream;
      } else if (isMobile && !isPortrait) {
        // „Çπ„Éû„ÉõÊ®™Âêë„Åç„ÅÆÂ†¥Âêà
        try {
          constraints = {
            video: {
              facingMode: 'user',
              width: { min: 640, ideal: 1280, max: 1920 },
              height: { min: 480, ideal: 720, max: 1080 },
              aspectRatio: { ideal: 1.777 }, // 16:9 = 1.777
            },
            audio: false,
          };
          finalStream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (e) {
          console.log(
            'üì± Ê®™Âêë„Åç„ÅÆÂà∂Á¥Ñ„ÅåÂ§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÇíÂÆüË°å„Åó„Åæ„Åô'
          );
          // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Çà„ÇäÁ∑©„ÅÑÂà∂Á¥Ñ
          finalStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'user' },
            audio: false,
          });
        }
      } else {
        // PC„ÅÆÂ†¥Âêà
        try {
          constraints = {
            video: {
              facingMode: 'user',
              width: { ideal: 1280 },
              height: { ideal: 720 },
              aspectRatio: { ideal: 1.777 },
            },
            audio: false,
          };
          finalStream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (e) {
          console.log('üíª PC„ÅÆÂà∂Á¥Ñ„ÅåÂ§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÇíÂÆüË°å„Åó„Åæ„Åô');
          // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Çà„ÇäÁ∑©„ÅÑÂà∂Á¥Ñ
          finalStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false,
          });
        }
      }

      console.log(
        'üì± Final constraints used:',
        typeof constraints !== 'undefined' ? constraints : 'No constraints set'
      );

      const stream = finalStream;

      // „Çπ„Éà„É™„Éº„É†„ÅÆÂÆüÈöõ„ÅÆË®≠ÂÆö„ÇíÁ¢∫Ë™ç
      const videoTrack = stream.getVideoTracks()[0];
      const settings = videoTrack.getSettings();
      console.log('üì∑ Actual camera settings:', {
        width: settings.width,
        height: settings.height,
        aspectRatio: settings.aspectRatio,
        facingMode: settings.facingMode,
      });

      videoElement.srcObject = stream;
      await videoElement.play();

      // „Éì„Éá„Ç™„ÅÆÂÆüÈöõ„ÅÆ„Çµ„Ç§„Ç∫„ÇíÁ¢∫Ë™ç
      console.log('üì∫ Video element dimensions:', {
        videoWidth: videoElement.videoWidth,
        videoHeight: videoElement.videoHeight,
        clientWidth: videoElement.clientWidth,
        clientHeight: videoElement.clientHeight,
      });

      // MediaPipe„Å´„Éï„É¨„Éº„É†„ÇíÈÄÅ„ÇãÂá¶ÁêÜ„ÇíÁã¨Ëá™„Å´ÂÆüË£Ö
      let animationId: number;
      let frameCount = 0;
      const sendFrame = async () => {
        if (faceMesh && videoElement && videoElement.readyState >= 2) {
          try {
            await faceMesh.send({ image: videoElement });
            frameCount++;
            // ÊúÄÂàù„ÅÆ„Éï„É¨„Éº„É†ÈÄÅ‰ø°„Çí„É≠„Ç∞
            if (frameCount === 1) {
              console.log('‚úÖ ÊúÄÂàù„ÅÆ„Éï„É¨„Éº„É†„ÇíMediaPipe„Å´ÈÄÅ‰ø°ÊàêÂäü');
            }
          } catch (error) {
            console.error('‚ùå MediaPipe„Éï„É¨„Éº„É†ÈÄÅ‰ø°„Ç®„É©„Éº:', error);
            console.error('„Ç®„É©„ÉºË©≥Á¥∞:', {
              faceMesh: !!faceMesh,
              videoElement: !!videoElement,
              readyState: videoElement?.readyState,
              error: error,
            });
          }
        }
        animationId = requestAnimationFrame(sendFrame);
      };

      // „Éï„É¨„Éº„É†ÈÄÅ‰ø°„ÇíÈñãÂßã
      console.log('üé¨ „Éï„É¨„Éº„É†ÈÄÅ‰ø°„É´„Éº„Éó„ÇíÈñãÂßã„Åó„Åæ„Åô');
      sendFrame();

      // „Ç´„É°„É©ÂÅúÊ≠¢ÊôÇ„Å´„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Åô„Çã„Åü„ÇÅ„Å´‰øùÂ≠ò
      camera = {
        stop: () => {
          if (animationId) {
            cancelAnimationFrame(animationId);
          }
          if (stream) {
            stream.getTracks().forEach(track => track.stop());
          }
        },
      };

      // Wait for video to be ready
      if (videoElement.readyState < 2) {
        await new Promise(resolve => {
          const checkReady = () => {
            if (videoElement.readyState >= 2) {
              resolve(true);
            } else {
              setTimeout(checkReady, 50);
            }
          };
          checkReady();
        });
      }

      // Reset detection state when camera starts
      faceDetected = false;
      faceDetectionCount = 0;
      faceDetectionStartTime = null;
      stablePosition = false;
      stableStartTime = null;
      progress = 0;

      initializationStep = 'processing';
      console.log('üì∑ „Ç´„É°„É©„Çπ„Éà„É™„Éº„É†„ÅÆÂèñÂæó„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü');
      console.log('üîÑ MediaPipe„ÅÆÂÆåÂÖ®ÂàùÊúüÂåñ„ÇíÂæÖÊ©ü‰∏≠...');

      // Don't dispatch cameraStarted yet - wait for MediaPipe to be fully ready
      // dispatch('cameraStarted'); // Moved to onResults after first frame processing
    } catch (error) {
      initializationStep = 'error';
      console.error('‚ùå „Ç´„É°„É©Ëµ∑Âãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      dispatch('error', {
        message:
          '„Ç´„É°„É©„ÅÆËµ∑Âãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Åó„Å∞„Çâ„ÅèÂæÖ„Å£„Å¶„Åã„Çâ„É™„Éà„É©„Ç§„Åó„Åæ„Åô„ÄÇ',
      });
    } finally {
      isStartingCamera = false;
    }
  }

  function onResults(results: any) {
    // ÊúÄÂàù„ÅÆÂëº„Å≥Âá∫„Åó„Çí„É≠„Ç∞
    if (!hasProcessedFirstFrame) {
      console.log('üéØ onResults „ÅåÂàù„ÇÅ„Å¶Âëº„Å∞„Çå„Åæ„Åó„Åü');
    }

    if (!canvasCtx && canvasElement) {
      canvasCtx = canvasElement.getContext('2d')!;
    }

    if (!canvasCtx || !canvasElement) {
      console.warn('‚ö†Ô∏è canvasCtx „Åæ„Åü„ÅØ canvasElement „ÅåÊ∫ñÂÇô„Åß„Åç„Å¶„ÅÑ„Åæ„Åõ„Çì');
      return;
    }

    // Check if this is the first successful frame processing
    if (!hasProcessedFirstFrame && !isMediaPipeFullyInitialized) {
      hasProcessedFirstFrame = true;
      isMediaPipeFullyInitialized = true;
      initializationStep = 'ready';
      console.log('‚úÖ MediaPipe„ÅÆÂàùÊúüÂåñ„ÅåÂÆåÂÖ®„Å´ÂÆå‰∫Ü„Åó„Åæ„Åó„Åü');
      console.log('üéâ „Ç´„É°„É©„Åå‰ΩøÁî®ÂèØËÉΩ„Å´„Å™„Çä„Åæ„Åó„Åü');
      dispatch('cameraStarted');
    }

    // „Éì„Éá„Ç™„ÅÆÂÆüÈöõ„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂèñÂæó
    const videoWidth =
      results.image.width ||
      results.image.videoWidth ||
      videoElement?.videoWidth ||
      720;
    const videoHeight =
      results.image.height ||
      results.image.videoHeight ||
      videoElement?.videoHeight ||
      1280;

    // „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„Çí„Éì„Éá„Ç™„ÅÆ„Çµ„Ç§„Ç∫„Å´ÂÆåÂÖ®„Å´‰∏ÄËá¥„Åï„Åõ„Çã
    if (
      canvasElement.width !== videoWidth ||
      canvasElement.height !== videoHeight
    ) {
      canvasElement.width = videoWidth;
      canvasElement.height = videoHeight;
      console.log('üìê Canvas resized to match video:', {
        width: videoWidth,
        height: videoHeight,
      });
    }

    // Clear canvas
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    // Save current video dimensions for coordinate transformation
    currentVideoWidth = videoWidth;
    currentVideoHeight = videoHeight;

    // „Éì„Éá„Ç™„Çí„Åù„ÅÆ„Åæ„Åæ„ÅÆ„Çµ„Ç§„Ç∫„ÅßÊèèÁîªÔºà„Çπ„Ç±„Éº„É™„É≥„Ç∞„Å™„ÅóÔºâ
    canvasCtx.drawImage(results.image, 0, 0, videoWidth, videoHeight);

    // Debug: Log drawing dimensions (only occasionally to avoid spam)
    if (Math.random() < 0.01) {
      // 1% chance to log
    }

    const hasFace =
      results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;
    // MediaPipeÁµêÊûú„ÅÆ„É≠„Ç∞„ÅØÂâäÈô§ÔºàÂøÖË¶ÅÊôÇ„ÅÆ„ÅøÊúâÂäπÂåñÔºâ
    // console.log('üì∏ MediaPipe results:', { hasFace, faceCount: results.multiFaceLandmarks?.length || 0 });

    if (hasFace) {
      const landmarks = results.multiFaceLandmarks[0];
      faceLandmarks = landmarks;

      // Calculate pose
      const pose = calculatePose(landmarks);
      // ÂßøÂã¢Ë®àÁÆó„ÅÆ„É≠„Ç∞„ÅØÂâäÈô§ÔºàÂøÖË¶ÅÊôÇ„ÅÆ„ÅøÊúâÂäπÂåñÔºâ
      // console.log('üìê Calculated pose:', pose);

      // Analyze expression (only if enabled)
      if (enableExpressionDetection === true) {
        currentExpression = expressionAnalyzer.analyzeExpression(landmarks);
      } else {
        currentExpression = null;
      }

      updateStability(pose);

      if (showMesh) {
        drawFaceMesh(landmarks);
      }

      // Face detection stability
      faceDetectionCount++;

      if (!faceDetected && faceDetectionCount >= FACE_DETECTION_THRESHOLD) {
        faceDetected = true;

        if (currentMode !== CaptureMode?.CAMERA_STARTUP) {
          faceDetectionStartTime = performance.now();

          // „Éá„Ç∂„Ç§„É≥„Å´„Å™„ÅÑ„Åü„ÇÅ„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°„Åó„Å™„ÅÑ
        }
      }

      // Check auto capture (exclude preview modes)
      if (
        currentMode !== CaptureMode?.CAMERA_STARTUP &&
        currentMode !== CaptureMode?.PREVIEW_BEFORE &&
        currentMode !== CaptureMode?.PREVIEW_AFTER
      ) {
        checkAutoCapture();
      }

      // Áµ±Âêà„Ç¨„Ç§„ÉÄ„É≥„ÇπÂà§ÂÆöÔºàÂßøÂã¢ÂÑ™ÂÖà„ÄÅË°®ÊÉÖ„ÅØÂßøÂã¢OK„ÅÆÂ†¥Âêà„ÅÆ„ÅøÔºâ
      const guidanceInfo = determineGuidance(
        pose,
        currentExpression,
        landmarks
      );

      dispatch('faceDetected', {
        landmarks,
        pose,
        expression: currentExpression, // Ë°®ÊÉÖ„Éá„Éº„Çø„ÇíËøΩÂä†
        stable: stablePosition,
        progress,
        guidance: guidanceInfo,
      });
    } else {
      // No face detected
      // console.log('‚ùå No face detected'); // „É≠„Ç∞ÂâäÈô§
      handleNoFaceDetected();
    }

    drawUIOverlays();
    canvasCtx.restore();
  }

  function drawFaceMesh(landmarks: any) {
    if (!canvasCtx) return;

    drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, {
      color: '#C0C0C070',
      lineWidth: 1,
    });
    drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, {
      color: '#FF3030',
    });
    drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE, {
      color: '#30FF30',
    });
    drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL, {
      color: '#E0E0E0',
    });
    drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS, {
      color: '#E0E0E0',
    });
  }

  function handleNoFaceDetected() {
    faceDetectionCount = 0;

    if (faceDetected) {
      faceDetected = false;
      faceDetectionStartTime = null;
    }

    stablePosition = false;
    stableStartTime = null;
    progress = 0;

    // Clear pose guidance in CAMERA_STARTUP mode
    if (currentMode === CaptureMode?.CAMERA_STARTUP) {
      showPoseGuidance = false;
      poseGuidanceMessage = '';
    }

    // „Éá„Ç∂„Ç§„É≥„Å´„Å™„ÅÑ„Åü„ÇÅ„Çπ„ÉÜ„Éº„Çø„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„ÅØÈÄÅ‰ø°„Åó„Å™„ÅÑ

    dispatch('faceDetected', {
      landmarks: null,
      pose: null,
      stable: false,
      progress: 0,
    });

    showPoseGuidance = false;
    lastGuidanceMessage = '';
  }

  function calculateFaceSize(landmarks: any): number {
    try {
      // È°î„ÅÆÂ¢ÉÁïå„ÇíË®àÁÆó
      let minX = 1,
        maxX = 0,
        minY = 1,
        maxY = 0;

      // È°î„ÅÆËº™ÈÉ≠„Éù„Ç§„É≥„Éà„Çí‰ΩøÁî®„Åó„Å¶Â¢ÉÁïå„ÇíË®àÁÆó
      const faceContourIndices = [
        10, 151, 9, 8, 168, 6, 197, 195, 5, 4, 1, 19, 94, 125, 142, 36, 205,
        206, 207, 213, 192, 147, 187, 207, 206, 205, 36, 142, 125, 94, 19, 1, 4,
        5, 195, 197, 6, 168, 8, 9, 151, 10,
      ];

      for (const index of faceContourIndices) {
        if (landmarks[index]) {
          minX = Math.min(minX, landmarks[index].x);
          maxX = Math.max(maxX, landmarks[index].x);
          minY = Math.min(minY, landmarks[index].y);
          maxY = Math.max(maxY, landmarks[index].y);
        }
      }

      // È°î„ÅÆ„Çµ„Ç§„Ç∫„ÇíË®àÁÆóÔºàÁîªÂÉè„Å´ÂØæ„Åô„ÇãÁõ∏ÂØæ„Çµ„Ç§„Ç∫Ôºâ
      const faceWidth = maxX - minX;
      const faceHeight = maxY - minY;
      const faceSize = Math.sqrt(
        faceWidth * faceWidth + faceHeight * faceHeight
      );

      return faceSize;
    } catch (error) {
      return 0;
    }
  }

  function calculatePose(landmarks: any) {
    // PHPÁâà„Å®ÂÆåÂÖ®„Å´Âêå„ÅòÂßøÂã¢Ë®àÁÆó„É≠„Ç∏„ÉÉ„ÇØ
    try {
      // ÁâπÂæ¥ÁÇπ„ÅÆÂèñÂæóÔºàPHP„Å®Âêå„Åò„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÔºâ
      const nose = landmarks[1];
      const leftEye = landmarks[33];
      const rightEye = landmarks[263];
      const leftMouth = landmarks[61];
      const rightMouth = landmarks[291];

      if (!nose || !leftEye || !rightEye || !leftMouth || !rightMouth) {
        throw new Error('Required landmarks not found');
      }

      // „É≠„Éº„É´ÔºàZËª∏ÂõûËª¢Ôºâ- ÁõÆ„ÅÆÂÇæ„Åç - „Éü„É©„Éº„É™„É≥„Ç∞ÂØæÂøú
      const eyeDiffY = rightEye.y - leftEye.y;
      const eyeDiffX = rightEye.x - leftEye.x;
      const roll = (-Math.atan2(eyeDiffY, eyeDiffX) * 180) / Math.PI;

      // „Éî„ÉÉ„ÉÅÔºàXËª∏ÂõûËª¢Ôºâ- Á∏¶ÊñπÂêë„ÅÆÂÇæ„Åç - ‰øÆÊ≠£Áâà
      const eyeCenter = {
        y: (leftEye.y + rightEye.y) / 2,
        z: (leftEye.z + rightEye.z) / 2,
      };

      // Èºª„Å®ÁõÆ„ÅÆ‰∏≠ÂøÉ„ÅÆ‰ΩçÁΩÆÈñ¢‰øÇ
      const eyeNoseY = eyeCenter.y - nose.y;
      const eyeNoseZ = eyeCenter.z - nose.z;

      // ËßíÂ∫¶Ë®àÁÆó - Á¨¶Âè∑„Å®ÂºïÊï∞„ÇíË™øÊï¥
      let rawPitch = (-Math.atan2(eyeNoseZ, eyeNoseY) * 180) / Math.PI;

      // 180Â∫¶ÂïèÈ°å„ÅÆËß£Ê±∫
      if (rawPitch > 90) {
        rawPitch = rawPitch - 180;
      } else if (rawPitch < -90) {
        rawPitch = rawPitch + 180;
      }

      // ÊúÄÁµÇÁöÑ„Å™„Éî„ÉÉ„ÉÅÂÄ§Ôºà„Éá„Éê„Ç§„ÇπÂà•„Ç™„Éï„Çª„ÉÉ„Éà - APIË®≠ÂÆö‰ΩøÁî®Ôºâ
      const pitchCalibration = config.poseCalculationConfig.pitchCalibration;
      const deviceAdjustment = getDevicePitchAdjustment(pitchCalibration);
      const pitch =
        rawPitch + pitchCalibration.baseOffsetDegrees + deviceAdjustment;

      // „É®„ÉºÔºàYËª∏ÂõûËª¢Ôºâ- Ê®™ÊñπÂêë„ÅÆÂêë„ÅçÔºàAPIË®≠ÂÆö‰ΩøÁî®Ôºâ
      const eyeMidPoint = {
        x: (leftEye.x + rightEye.x) / 2,
      };
      const noseMidOffset = eyeMidPoint.x - nose.x;
      const yaw = noseMidOffset * config.poseCalculationConfig.yawSensitivity;

      // È°î„ÅÆ„Çµ„Ç§„Ç∫„ÇíË®àÁÆó
      const faceSize = calculateFaceSize(landmarks);

      // Ë∑ùÈõ¢„Å®ÂìÅË≥™„ÅÆË®àÁÆóÔºàAPIË®≠ÂÆö‰ΩøÁî®Ôºâ
      const qualityConfig = config.poseCalculationConfig.qualityCalculation;
      const eyeDistance = Math.sqrt(eyeDiffX * eyeDiffX + eyeDiffY * eyeDiffY);
      const distance = Math.max(
        qualityConfig.distanceRange.min,
        Math.min(qualityConfig.distanceRange.max, 1.0 / eyeDistance)
      );
      const quality = Math.max(
        0.0,
        Math.min(1.0, faceSize * qualityConfig.faceSizeMultiplier)
      );

      const result = {
        roll: Math.round(roll * 10) / 10,
        pitch: Math.round(pitch * 10) / 10,
        yaw: Math.round(yaw * 10) / 10,
        distance: Math.round(distance * 100) / 100,
        quality: Math.round(quality * 100) / 100,
        faceSize: Math.round(faceSize * 1000) / 1000,
      };

      return result;
    } catch (error) {
      return {
        roll: 0,
        pitch: 0,
        yaw: 0,
        distance: 1.0,
        quality: 0.0,
        faceSize: 0.0,
      };
    }
  }

  function updateStability(pose: any) {
    const now = performance.now();

    // PHPÁâà„Å®Âêå„ÅòÂé≥„Åó„ÅÑÊù°‰ª∂
    const isGoodPose =
      Math.abs(pose.roll) < THRESHOLDS.roll &&
      Math.abs(pose.pitch) < THRESHOLDS.pitch &&
      Math.abs(pose.yaw) < THRESHOLDS.yaw &&
      pose.quality >= MIN_FACE_QUALITY &&
      pose.faceSize >= MIN_FACE_SIZE;

    // Ë°®ÊÉÖ„ÉÅ„Çß„ÉÉ„ÇØ - Ë°®ÊÉÖ„Å´ÂïèÈ°å„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂÆâÂÆöÁä∂ÊÖã„Å´„Åó„Å™„ÅÑ
    const isGoodExpression =
      enableExpressionDetection === true
        ? currentExpression
          ? expressionAnalyzer.isExpressionAcceptable(currentExpression)
          : true
        : true; // Expression detection disabled, assume OK

    // ÂßøÂã¢„Å®Ë°®ÊÉÖ„ÅÆ‰∏°Êñπ„ÅåËâØÂ•Ω„Å™Â†¥Âêà„ÅÆ„ÅøÂÆâÂÆöÁä∂ÊÖã„Å®„Åô„Çã
    const isStable = isGoodPose && isGoodExpression;

    // ÂßøÂã¢ÂÆâÂÆöÊÄß„ÉÅ„Çß„ÉÉ„ÇØ„ÅÆ„É≠„Ç∞„ÅØÂâäÈô§ÔºàÂøÖË¶ÅÊôÇ„ÅÆ„ÅøÊúâÂäπÂåñÔºâ
    // console.log('üéØ Pose stability check:', { roll: pose.roll.toFixed(1), pitch: pose.pitch.toFixed(1), yaw: pose.yaw.toFixed(1), isGoodPose, isGoodExpression, isStable, progress: progress.toFixed(1) });

    if (isStable) {
      if (!stablePosition) {
        stablePosition = true;
        stableStartTime = now;
        showPoseGuidance = true;
        poseGuidanceMessage = 'ËâØ„ÅÑÂßøÂã¢„Åß„ÅôÔºÅ‰øùÊåÅ„Åó„Å¶„Åè„Å†„Åï„ÅÑ';
        poseGuidanceType = 'success';

        // ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏„ÅØ2ÁßíÂæå„Å´ÈùûË°®Á§∫„Å´„Åô„Çã
        setTimeout(() => {
          if (stablePosition) {
            showPoseGuidance = false;
          }
        }, 2000);
      }

      if (stableStartTime) {
        const elapsed = (now - stableStartTime) / 1000;
        // „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„ÇíÂßøÂã¢ÂÆâÂÆöÂæå„ÅÆËá™ÂãïÊíÆÂΩ±ÂæÖÊ©üÊôÇÈñìÔºàFACE_DETECTION_DELAYÔºâ„Å´Âêà„Çè„Åõ„Çã
        progress = Math.min((elapsed / FACE_DETECTION_DELAY) * 100, 100);

        if (progress >= 100) {
        }
      }
    } else {
      // ÂßøÂã¢„Åæ„Åü„ÅØË°®ÊÉÖ„Å´ÂïèÈ°å„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„É™„Çª„ÉÉ„Éà
      if (stablePosition) {
      }
      stablePosition = false;
      stableStartTime = null;
      progress = 0;

      // Guidance messages - ÂßøÂã¢„ÅÆ„Ç¨„Ç§„ÉÄ„É≥„Çπ„ÅÆ„ÅøÊõ¥Êñ∞ÔºàË°®ÊÉÖ„ÅØÁµ±Âêà„Ç¨„Ç§„ÉÄ„É≥„Çπ„ÅßÂá¶ÁêÜÔºâ
      if (now - lastGuidanceUpdate > GUIDANCE_UPDATE_INTERVAL && !isGoodPose) {
        updatePoseGuidance(pose);
        lastGuidanceUpdate = now;
      }
    }
  }

  // ÂßøÂã¢„Å´Âü∫„Å•„ÅÑ„Å¶„Ç¨„Ç§„ÉÄ„É≥„Çπ„Éá„Éº„Çø„ÇíÂèñÂæóÔºàEnum„Éô„Éº„ÇπÔºâ
  function getPoseGuidanceData(pose: any): PoseGuidanceData | null {
    if (!pose) return null;

    // ÂÑ™ÂÖàÈ†Ü‰Ωç„Å´Âæì„Å£„Å¶Âà§ÂÆöÔºàPHPÁâà„Å®Âêå„ÅòÈ†ÜÁï™Ôºâ
    if (pose.faceSize < MIN_FACE_SIZE) {
      return POSE_GUIDANCE_MAP.tooFar;
    } else if (pose.quality < MIN_FACE_QUALITY) {
      return POSE_GUIDANCE_MAP.lowQuality;
    } else if (Math.abs(pose.roll) >= THRESHOLDS.roll) {
      return pose.roll > 0
        ? POSE_GUIDANCE_MAP.rollPositive
        : POSE_GUIDANCE_MAP.rollNegative;
    } else if (Math.abs(pose.pitch) >= THRESHOLDS.pitch) {
      return pose.pitch > 0
        ? POSE_GUIDANCE_MAP.pitchPositive
        : POSE_GUIDANCE_MAP.pitchNegative;
    } else if (Math.abs(pose.yaw) >= THRESHOLDS.yaw) {
      return pose.yaw > 0
        ? POSE_GUIDANCE_MAP.yawPositive
        : POSE_GUIDANCE_MAP.yawNegative;
    } else {
      return POSE_GUIDANCE_MAP.perfect;
    }
  }

  function getGuidanceDirection(pose: any): PoseGuidanceDirection | null {
    const guidanceData = getPoseGuidanceData(pose);
    return guidanceData?.direction || null;
  }

  // PHP„Å®Âêå„ÅòÈºª„ÅÆ‰ΩçÁΩÆË®àÁÆóÔºàÂÆåÂÖ®ÁßªÊ§çÁâàÔºâ
  function getNosePosition(landmarks: any) {
    if (
      !landmarks ||
      !canvasElement ||
      currentVideoWidth === 0 ||
      currentVideoHeight === 0
    ) {
      // Debug: Log why getNosePosition is returning null
      if (Math.random() < 0.1) {
        // 10% chance to avoid spam
      }
      return null;
    }

    // Èºª„ÅÆÂÖàÁ´Ø„ÅÆ„É©„É≥„Éâ„Éû„Éº„ÇØÔºà„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ1Ôºâ
    const nose = landmarks[1];
    if (!nose) return null;

    // onResultsÈñ¢Êï∞„Å®Âêå„Åò„Ç¢„Çπ„Éö„ÇØ„ÉàÊØîË®àÁÆó„Çí‰ΩøÁî®
    const videoWidth = currentVideoWidth;
    const videoHeight = currentVideoHeight;
    const canvasWidth = canvasElement.width;
    const canvasHeight = canvasElement.height;

    const videoAspect = videoWidth / videoHeight;
    const canvasAspect = canvasWidth / canvasHeight;

    let drawWidth, drawHeight, drawX, drawY;

    if (videoAspect > canvasAspect) {
      // Video is wider - fit to canvas height
      drawHeight = canvasHeight;
      drawWidth = drawHeight * videoAspect;
      drawX = (canvasWidth - drawWidth) / 2;
      drawY = 0;
    } else {
      // Video is taller - fit to canvas width
      drawWidth = canvasWidth;
      drawHeight = drawWidth / videoAspect;
      drawX = 0;
      drawY = (canvasHeight - drawHeight) / 2;
    }

    // ÂÆüÈöõ„ÅÆÊèèÁîªÈ†òÂüüÂÜÖ„Åß„ÅÆÂ∫ßÊ®ôË®àÁÆó
    const noseX = (1 - nose.x) * drawWidth + drawX;
    const noseY = nose.y * drawHeight + drawY;

    // Ë°®Á§∫„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Å¶„Çπ„Ç±„Éº„É™„É≥„Ç∞
    const canvasRect = canvasElement.getBoundingClientRect();
    const scaleX = canvasRect.width / canvasElement.width;
    const scaleY = canvasRect.height / canvasElement.height;

    const displayX = noseX * scaleX;
    const displayY = noseY * scaleY;

    // Debug: Log successful nose position calculation
    if (Math.random() < 0.05) {
      // 5% chance to avoid spam
    }

    return { x: displayX, y: displayY };
  }

  function updatePoseGuidance(pose: any) {
    // Don't show pose guidance in CAMERA_STARTUP mode
    if (currentMode === CaptureMode?.CAMERA_STARTUP) {
      return;
    }

    // „Ç¨„Ç§„ÉÄ„É≥„Çπ„Éá„Éº„Çø„ÇíÂèñÂæóÔºàEnum„Éô„Éº„ÇπÔºâ
    const guidanceData = getPoseGuidanceData(pose);

    if (!guidanceData) return;

    const { message, type } = guidanceData;

    if (message) {
      poseGuidanceMessage = message;
      poseGuidanceType = type;
      showPoseGuidance = true;
      lastGuidanceMessage = message;

      // ÂßøÂã¢„ÅåÊÇ™„ÅÑÈñì„ÅØÁ∂ôÁ∂öÁöÑ„Å´Ë°®Á§∫ÔºàÂêå„Åò„É°„ÉÉ„Çª„Éº„Ç∏„Åß„ÇÇÁ∂ôÁ∂öË°®Á§∫Ôºâ
    }
  }

  // PHP„Å®Âêå„Åò„Éî„Éé„Ç≠„Ç™Ê£íÔºà„Éî„É≥„ÇØËª∏ÔºâÊèèÁîªÊ©üËÉΩ
  function drawPoseAxes(landmarks: any) {
    if (!canvasCtx || !canvasElement) return;

    // ÁèæÂú®„ÅÆÂßøÂã¢„ÇíË®àÁÆó
    const pose = calculatePose(landmarks);

    // Èè°ÂÉèË°®Á§∫„Å´ÂØæÂøú„Åô„Çã„Åü„ÇÅ„ÅÆÂ§âÊèõ
    canvasCtx.scale(-1, 1);
    canvasCtx.translate(-canvasElement.width, 0);

    const nose = landmarks[1];
    const scale = 0.2; // Ëª∏„ÅÆÈï∑„Åï

    // Â∫ßÊ®ôËª∏„ÅÆÊèèÁîªÔºàÈºª„Åã„Çâ‰º∏„Å≥„Çã„Éî„É≥„ÇØËª∏Ôºâ
    // „Éü„É©„Éº„É™„É≥„Ç∞ÊôÇ„ÅÆÂ∫ßÊ®ô„Å´Â§âÊèõ
    const noseX = (1 - nose.x) * canvasElement.width;
    const noseY = nose.y * canvasElement.height;

    // ZËª∏Ôºà„Éî„É≥„ÇØÔºâ- „É®„ÉºÔºàÈ°î„ÅÆÂêë„ÅçÔºâ„Å´Âøú„Åò„Å¶ÊñπÂêë„ÅåÂ§â„Çè„Çã
    const zAxisX =
      noseX +
      Math.sin((pose.yaw * Math.PI) / 180) * scale * canvasElement.width;

    // ÂÜÜÊü±„ÅÆÊèèÁîªÔºàZËª∏Ôºâ
    const cylinderWidth = 12; // ÂÜÜÊü±„ÅÆÂπÖ

    // „Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„ÅßÂÜÜÊü±ÂäπÊûú„Çí‰ΩúÊàê
    const gradient = canvasCtx.createLinearGradient(
      noseX,
      noseY,
      zAxisX,
      noseY
    );
    gradient.addColorStop(0, '#E05179'); // „Éî„É≥„ÇØËâ≤ÔºàÂßãÁÇπÔºâ
    gradient.addColorStop(1, 'rgba(224, 81, 121, 0.8)'); // Êòé„Çã„ÅÑ„Éî„É≥„ÇØËâ≤ÔºàÁµÇÁÇπÔºâ

    // ÂÜÜÊü±„ÅÆÊú¨‰Ωì„ÇíÊèèÁîª
    canvasCtx.beginPath();
    canvasCtx.moveTo(noseX, noseY - cylinderWidth / 2);
    canvasCtx.lineTo(zAxisX, noseY - cylinderWidth / 2);
    canvasCtx.lineTo(zAxisX, noseY + cylinderWidth / 2);
    canvasCtx.lineTo(noseX, noseY + cylinderWidth / 2);
    canvasCtx.closePath();
    canvasCtx.fillStyle = gradient;
    canvasCtx.fill();

    // ÁµÇÁÇπ„ÅÆÂÜÜ„ÇíÊèèÁîª
    canvasCtx.beginPath();
    canvasCtx.arc(zAxisX, noseY, cylinderWidth / 2, 0, Math.PI * 2);
    canvasCtx.fillStyle = 'rgba(224, 81, 121, 0.8)';
    canvasCtx.fill();

    // ÂßãÁÇπ„ÅÆÂÜÜ„ÇíÊèèÁîª
    canvasCtx.beginPath();
    canvasCtx.arc(noseX, noseY, cylinderWidth / 2, 0, Math.PI * 2);
    canvasCtx.fillStyle = '#E05179';
    canvasCtx.fill();
  }

  function checkAutoCapture() {
    if (!faceDetected || !stableStartTime) return;

    // ÂßøÂã¢„ÅåÂÆâÂÆö„Åó„Å¶„Åã„Çâ„ÅÆÁµåÈÅéÊôÇÈñì„ÇíË®àÁÆó
    const elapsed = (performance.now() - stableStartTime) / 1000;

    // Ë°®ÊÉÖ„ÉÅ„Çß„ÉÉ„ÇØ - Ë°®ÊÉÖ„Å´ÂïèÈ°å„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÊíÆÂΩ±„Åó„Å™„ÅÑ
    const expressionOk =
      enableExpressionDetection === true
        ? currentExpression
          ? expressionAnalyzer.isExpressionAcceptable(currentExpression)
          : true
        : true; // Expression detection disabled, assume OK

    // ÂßøÂã¢„ÅåÂÆâÂÆö„Åó„Å¶„Åã„Çâ3ÁßíÁµåÈÅé + Ë°®ÊÉÖ„ÇÇËâØÂ•Ω„Å™Â†¥Âêà„Å´ÊíÆÂΩ±
    if (
      elapsed >= FACE_DETECTION_DELAY &&
      stablePosition &&
      progress >= 100 &&
      expressionOk
    ) {
      dispatch('autoCapture', { landmarks: faceLandmarks });

      // Reset detection to prevent multiple captures
      faceDetectionStartTime = null;
      faceDetected = false;
      stablePosition = false;
      stableStartTime = null;
      progress = 0;
    }
  }

  function drawUIOverlays() {
    if (!canvasCtx || !canvasElement) return;

    // Save the current transformation matrix
    canvasCtx.save();

    // „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„ÅÆ„ÅøÊèèÁîªÔºàÁôΩ„ÅÑÂÜÜ„ÅØCSS„ÅßË°®Á§∫Ôºâ
    if (
      currentMode !== CaptureMode?.CAMERA_STARTUP &&
      faceDetected &&
      stablePosition &&
      progress > 0
    ) {
      const centerX = canvasElement.width / 2;
      const centerY = canvasElement.height / 2;
      // CSS „ÅÆ„Éû„Çπ„ÇØÂÜÜ„Å®Âêå„Åò„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„ÇãÔºà„É¨„Çπ„Éù„É≥„Ç∑„ÉñÂØæÂøúÔºâ
      const circleSize = Math.min(300, window.innerWidth * 0.5);
      const radius = circleSize / 2 - 10; // „Éû„Çπ„ÇØÂÜÜ„ÅÆÂÜÖÂÅ¥„Å´„Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„ÇíÊèèÁîª

      const progressAngle = (progress / 100) * 2 * Math.PI - Math.PI / 2;

      canvasCtx.beginPath();
      canvasCtx.arc(centerX, centerY, radius, -Math.PI / 2, progressAngle);
      canvasCtx.strokeStyle = '#00BEB9';
      canvasCtx.lineWidth = 47;
      canvasCtx.stroke();
    }

    // „Éî„Éé„Ç≠„Ç™Ê£íÔºà„Éî„É≥„ÇØËª∏Ôºâ„ÅÆÊèèÁîª - PHP„Å®Âêå„ÅòÂÆüË£Ö
    if (faceLandmarks && faceDetected) {
      drawPoseAxes(faceLandmarks);
    }

    // Restore the transformation matrix
    canvasCtx.restore();
  }

  function cleanup() {
    // Stop camera but don't destroy faceMesh (for reuse)
    if (camera) {
      camera.stop();
      camera = null;
    }

    // Stop video stream
    if (videoElement && videoElement.srcObject) {
      const stream = videoElement.srcObject as MediaStream;
      stream.getTracks().forEach(track => {
        track.stop();
      });
      videoElement.srcObject = null;
    }

    // Reset detection state
    faceDetected = false;
    faceDetectionCount = 0;
    faceDetectionStartTime = null;
    stablePosition = false;
    stableStartTime = null;
    progress = 0;
    isStartingCamera = false;
  }

  // Complete cleanup function for component destruction
  function completeCleanup() {
    cleanup();

    if (faceMesh) {
      faceMesh.close();
      faceMesh = null;
    }
  }

  // Export cleanup functions for external use
  export { cleanup, completeCleanup };

  // Export function to get current face landmarks
  export function getCurrentFaceLandmarks() {
    return faceLandmarks;
  }

  // Export startCamera function for external use
  export { startCamera };

  // „Ç≠„É£„É≥„Éê„ÇπÂêåÊúüÊ©üËÉΩ„ÅØÂâäÈô§

  // Export guidance state
  export { showPoseGuidance, poseGuidanceMessage, poseGuidanceType };

  // ÂßøÂã¢„Å®Ë°®ÊÉÖ„ÇíÁµ±Âêà„Åó„Åü„Ç¨„Ç§„ÉÄ„É≥„ÇπÂà§ÂÆö
  function determineGuidance(
    pose: any,
    expression: ExpressionData | null,
    landmarks: any[]
  ) {
    // 1. „Åæ„ÅöÂßøÂã¢„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºàÊó¢Â≠ò„É≠„Ç∏„ÉÉ„ÇØÔºâ
    const poseGuidance = getPoseGuidanceData(pose);

    // ÂßøÂã¢„Å´ÂïèÈ°å„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂßøÂã¢„Ç¨„Ç§„ÉÄ„É≥„Çπ„ÇíÂÑ™ÂÖà
    if (poseGuidance?.type !== PoseGuidanceType.SUCCESS) {
      return {
        show: showPoseGuidance,
        message: poseGuidanceMessage,
        type: poseGuidanceType,
        direction: getGuidanceDirection(pose),
        nosePosition: getNosePosition(landmarks),
        source: 'pose',
      };
    }

    // 2. ÂßøÂã¢OK„ÅÆÂ†¥Âêà„ÄÅË°®ÊÉÖ„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºàË°®ÊÉÖÊ§úÁü•„ÅåÊúâÂäπ„Å™Â†¥Âêà„ÅÆ„ÅøÔºâ
    if (enableExpressionDetection === true && expression) {
      const expressionGuidance = getExpressionGuidanceData(expression);
      if (expressionGuidance) {
        return {
          show: true,
          message: expressionGuidance.message,
          type: expressionGuidance.type,
          direction: expressionGuidance.direction,
          nosePosition: getNosePosition(landmarks),
          source: 'expression',
        };
      }
    }

    // „Åô„Åπ„Å¶OK„ÅÆÂ†¥Âêà
    return {
      show: true,
      message: POSE_GUIDANCE_MAP.perfect.message,
      type: POSE_GUIDANCE_MAP.perfect.type,
      direction: null,
      nosePosition: getNosePosition(landmarks),
      source: 'success',
    };
  }

  // Ë°®ÊÉÖÂïèÈ°å„ÅÆÂÑ™ÂÖàÈ†Ü‰Ωç‰ªò„Åç„ÉÅ„Çß„ÉÉ„ÇØ
  function getExpressionGuidanceData(
    expression: ExpressionData
  ): PoseGuidanceData | null {
    if (!expression.isCalibrated) {
      return POSE_GUIDANCE_MAP.expressionCalibrating;
    }

    // ExpressionAnalyzer„ÅÆË®≠ÂÆöÂÄ§„Çí‰ΩøÁî®„Åó„Å¶‰∏ÄË≤´ÊÄß„Çí‰øù„Å§
    const settings = expressionAnalyzer.getSettings();

    // ÂÑ™ÂÖàÈ†Ü‰ΩçÔºöÁ¨ëÈ°î > Áúâ > ÁõÆ„ÅÆÂäõ„Åø
    // ExpressionAnalyzer„Å®Âêå„ÅòÊù°‰ª∂„Çí‰ΩøÁî®Ôºà>= „Åã„Çâ < „Å∏„ÅÆÂê¶ÂÆö„Åß‰∏ÄËá¥„Åï„Åõ„ÇãÔºâ
    if (expression.mouthSmile >= settings.smileThreshold) {
      return POSE_GUIDANCE_MAP.smileTooMuch;
    }
    if (expression.eyebrowRaise >= settings.eyebrowThreshold) {
      return POSE_GUIDANCE_MAP.eyebrowRaised;
    }
    if (expression.eyeTension >= settings.eyeTensionThreshold) {
      return POSE_GUIDANCE_MAP.eyeTension;
    }

    return null; // Ë°®ÊÉÖ„Å´ÂïèÈ°å„Å™„Åó
  }
</script>

<!-- This component doesn't render anything directly -->
<!-- It only handles face detection logic and dispatches events -->
