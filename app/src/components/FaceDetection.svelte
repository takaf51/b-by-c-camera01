<script lang="ts">
  import { onMount, onDestroy, createEventDispatcher } from 'svelte';
  import { FaceMesh } from '@mediapipe/face_mesh/face_mesh';
  import { Camera as MediaPipeCamera } from '@mediapipe/camera_utils/camera_utils';
  import {
    drawConnectors,
    FACEMESH_TESSELATION,
    FACEMESH_RIGHT_EYE,
    FACEMESH_LEFT_EYE,
    FACEMESH_FACE_OVAL,
    FACEMESH_LIPS,
  } from '@mediapipe/drawing_utils/drawing_utils';

  const dispatch = createEventDispatcher();

  // Props
  export let videoElement: HTMLVideoElement | undefined = undefined;
  export let canvasElement: HTMLCanvasElement | undefined = undefined;
  export let showMesh: boolean = true;
  export let currentMode: string = 'idle';
  // mirrorMode „ÅØ‰ΩøÁî®„Åó„Å™„ÅÑ„Åü„ÇÅÂâäÈô§

  // Constants
  export const CAPTURE_COUNT: number = 1;
  export let CaptureMode: any;

  // MediaPipe instances
  let faceMesh: any;
  let camera: any;
  let canvasCtx: CanvasRenderingContext2D | null = null;
  let isStartingCamera = false;

  // Face detection state
  let faceDetectionCount = 0;
  let faceDetected = false;
  let faceDetectionStartTime: number | null = null;
  let faceLandmarks: any = null;

  // Video dimensions for accurate coordinate transformation
  let currentVideoWidth = 0;
  let currentVideoHeight = 0;

  // Constants - PHPÁâà„Å®Âêå„ÅòÂé≥„Åó„ÅÑË®≠ÂÆö
  const FACE_DETECTION_THRESHOLD = 5; // Increased from 3 to 5
  const FACE_DETECTION_DELAY = 3.0; // ÂßøÂã¢ÂÆâÂÆöÂæå„ÅÆËá™ÂãïÊíÆÂΩ±„Åæ„Åß„ÅÆÂæÖÊ©üÊôÇÈñì„Çí3Áßí„Å´Ë®≠ÂÆö
  // const STABILITY_TIME = 1.5; // ‰∏çË¶Å„Å´„Å™„Å£„Åü„Åü„ÇÅÂâäÈô§ÔºàFACE_DETECTION_DELAY„Çí‰ΩøÁî®Ôºâ
  const THRESHOLDS = {
    roll: 10.0, // Reduced from 15.0 to 10.0 degrees
    pitch: 10.0, // Reduced from 15.0 to 10.0 degrees
    yaw: 10.0, // Reduced from 15.0 to 10.0 degrees
  };

  // Face size and quality thresholds like PHP version
  const MIN_FACE_SIZE = 0.15; // Minimum face size relative to image
  const MIN_FACE_QUALITY = 0.6; // Minimum face quality score

  // Pose and stability tracking
  let stablePosition = false;
  let stableStartTime: number | null = null;
  let stableFrameCount = 0;
  let progress = 0;

  // Guidance
  let poseGuidanceMessage = '';
  let poseGuidanceType = '';
  let showPoseGuidance = false;
  let lastGuidanceUpdate = 0;
  let lastGuidanceMessage = '';
  const GUIDANCE_UPDATE_INTERVAL = 100; // „Çà„ÇäÈ†ªÁπÅ„Å´„Ç¨„Ç§„ÉÄ„É≥„Çπ„ÇíÊõ¥Êñ∞
  // GUIDANCE_DISPLAY_DURATION „ÅØ‰ΩøÁî®„Åó„Å™„ÅÑÔºàÁ∂ôÁ∂öË°®Á§∫„ÅÆ„Åü„ÇÅÔºâ

  // syncIntervalÂ§âÊï∞„ÅØÂâäÈô§

  onMount(async () => {
    console.log('üöÄ FaceDetection component mounted');

    try {
      await initializeMediaPipe();
      console.log('‚úÖ MediaPipe initialized, ready for camera start');
    } catch (error) {
      console.error('‚ùå Face detection initialization failed:', error);
      dispatch('error', {
        message:
          'Face detection initialization failed: ' +
          (error instanceof Error ? error.message : String(error)),
      });
    }
  });

  // Public method to reset detection state
  export function resetDetectionState() {
    console.log('üîÑ Resetting face detection state');

    // Reset all detection-related variables
    stablePosition = false;
    stableFrameCount = 0;
    lastGuidanceUpdate = 0;
    showPoseGuidance = false;
    poseGuidanceMessage = '';
    poseGuidanceType = '';

    console.log('‚úÖ Face detection state reset completed');
  }

  onDestroy(() => {
    completeCleanup();
  });

  // Remove automatic camera starting - now controlled externally

  // Watch for mode changes (debug disabled)
  // $: if (currentMode) { console.log('üì± Mode changed:', currentMode); }

  async function initializeMediaPipe() {
    console.log('üîß Initializing MediaPipe FaceMesh...');

    faceMesh = new FaceMesh({
      locateFile: (file: string) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
      },
    });

    // Use same settings as PHP version
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.7, // Increased from 0.5
      minTrackingConfidence: 0.7, // Increased from 0.5
      selfieMode: false,
      staticImageMode: false,
    });

    faceMesh.onResults(onResults);
    console.log('‚úÖ MediaPipe FaceMesh initialized');
  }

  // „Ç≠„É£„É≥„Éê„ÇπÂêåÊúüÊ©üËÉΩ„ÅØÂâäÈô§

  async function startCamera() {
    console.log('üîç FaceDetection: Starting camera check:', {
      hasVideoElement: !!videoElement,
      hasFaceMesh: !!faceMesh,
      videoElement: videoElement,
      faceMesh: faceMesh,
    });

    if (!videoElement || !faceMesh) {
      console.warn('‚ö†Ô∏è Cannot start camera: missing videoElement or faceMesh', {
        videoElement: !!videoElement,
        faceMesh: !!faceMesh,
      });
      return;
    }

    if (isStartingCamera) {
      console.log('‚è≥ Camera is already starting, skipping...');
      return;
    }

    isStartingCamera = true;
    try {
      console.log('üìπ Starting camera...');
      console.log('üìä Video element state:', {
        readyState: videoElement.readyState,
        hasStream: !!videoElement.srcObject,
        videoWidth: videoElement.videoWidth,
        videoHeight: videoElement.videoHeight,
      });

      camera = new MediaPipeCamera(videoElement, {
        onFrame: async () => {
          if (faceMesh && videoElement) {
            try {
              await faceMesh.send({ image: videoElement });
            } catch (error) {
              console.warn('MediaPipe processing error:', error);
            }
          }
        },
        width: 640,
        height: 480,
      });

      await camera.start();
      console.log('‚úÖ Camera started successfully');
      console.log('üìä Video element after start:', {
        readyState: videoElement.readyState,
        hasStream: !!videoElement.srcObject,
        videoWidth: videoElement.videoWidth,
        videoHeight: videoElement.videoHeight,
        currentSrc: videoElement.currentSrc,
        srcObject: videoElement.srcObject ? 'MediaStream' : 'null',
      });

      // Wait for video to be ready
      if (videoElement.readyState < 2) {
        console.log('‚è≥ Waiting for video to be ready...');
        await new Promise(resolve => {
          const checkReady = () => {
            if (videoElement.readyState >= 2) {
              console.log('‚úÖ Video is now ready:', {
                readyState: videoElement.readyState,
                videoWidth: videoElement.videoWidth,
                videoHeight: videoElement.videoHeight,
              });

              resolve(true);
            } else {
              setTimeout(checkReady, 50);
            }
          };
          checkReady();
        });
      }

      // Reset detection state when camera starts
      faceDetected = false;
      faceDetectionCount = 0;
      faceDetectionStartTime = null;
      stablePosition = false;
      stableStartTime = null;
      progress = 0;

      dispatch('cameraStarted');
    } catch (error) {
      console.error('‚ùå Camera startup failed:', error);
      dispatch('error', {
        message:
          'Camera startup failed: ' +
          (error instanceof Error ? error.message : String(error)),
      });
    } finally {
      isStartingCamera = false;
    }
  }

  function onResults(results: any) {
    if (!canvasCtx && canvasElement) {
      canvasCtx = canvasElement.getContext('2d')!;
    }

    if (!canvasCtx) return;

    // Clear canvas
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement!.width, canvasElement!.height);

    // Draw video with proper aspect ratio handling
    const videoWidth = results.image.width || results.image.videoWidth;
    const videoHeight = results.image.height || results.image.videoHeight;
    const canvasWidth = canvasElement!.width;
    const canvasHeight = canvasElement!.height;

    // Save current video dimensions for coordinate transformation
    currentVideoWidth = videoWidth;
    currentVideoHeight = videoHeight;

    // Debug: Log video dimensions when they change
    if (Math.random() < 0.01) {
      // 1% chance to avoid spam
      console.log('üìä Video dimensions saved:', {
        videoWidth: currentVideoWidth,
        videoHeight: currentVideoHeight,
        canvasWidth,
        canvasHeight,
      });
    }

    // Calculate scaling to fit video into canvas while maintaining aspect ratio
    const videoAspect = videoWidth / videoHeight;
    const canvasAspect = canvasWidth / canvasHeight;

    let drawWidth, drawHeight, drawX, drawY;

    if (videoAspect > canvasAspect) {
      // Video is wider - fit to canvas height
      drawHeight = canvasHeight;
      drawWidth = drawHeight * videoAspect;
      drawX = (canvasWidth - drawWidth) / 2;
      drawY = 0;
    } else {
      // Video is taller - fit to canvas width
      drawWidth = canvasWidth;
      drawHeight = drawWidth / videoAspect;
      drawX = 0;
      drawY = (canvasHeight - drawHeight) / 2;
    }

    canvasCtx.drawImage(results.image, drawX, drawY, drawWidth, drawHeight);

    // Debug: Log drawing dimensions (only occasionally to avoid spam)
    if (Math.random() < 0.01) {
      // 1% chance to log
      console.log('üé® Canvas drawing debug:', {
        video: { width: videoWidth, height: videoHeight, aspect: videoAspect },
        canvas: {
          width: canvasWidth,
          height: canvasHeight,
          aspect: canvasAspect,
        },
        draw: { x: drawX, y: drawY, width: drawWidth, height: drawHeight },
      });
    }

    const hasFace =
      results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;
    // MediaPipeÁµêÊûú„ÅÆ„É≠„Ç∞„ÅØÂâäÈô§ÔºàÂøÖË¶ÅÊôÇ„ÅÆ„ÅøÊúâÂäπÂåñÔºâ
    // console.log('üì∏ MediaPipe results:', { hasFace, faceCount: results.multiFaceLandmarks?.length || 0 });

    if (hasFace) {
      const landmarks = results.multiFaceLandmarks[0];
      faceLandmarks = landmarks;

      // Calculate pose
      const pose = calculatePose(landmarks);
      // ÂßøÂã¢Ë®àÁÆó„ÅÆ„É≠„Ç∞„ÅØÂâäÈô§ÔºàÂøÖË¶ÅÊôÇ„ÅÆ„ÅøÊúâÂäπÂåñÔºâ
      // console.log('üìê Calculated pose:', pose);

      updateStability(pose);

      if (showMesh) {
        drawFaceMesh(landmarks);
      }

      // Face detection stability
      faceDetectionCount++;

      if (!faceDetected && faceDetectionCount >= FACE_DETECTION_THRESHOLD) {
        faceDetected = true;

        if (currentMode !== CaptureMode?.CAMERA_STARTUP) {
          faceDetectionStartTime = performance.now();
          console.log(
            'üë§ Face detection started at:',
            new Date().toLocaleTimeString()
          );
          // „Éá„Ç∂„Ç§„É≥„Å´„Å™„ÅÑ„Åü„ÇÅ„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°„Åó„Å™„ÅÑ
        }
      }

      // Check auto capture (exclude preview modes)
      if (
        currentMode !== CaptureMode?.CAMERA_STARTUP &&
        currentMode !== CaptureMode?.PREVIEW_BEFORE &&
        currentMode !== CaptureMode?.PREVIEW_AFTER
      ) {
        checkAutoCapture();
      }

      const guidanceInfo = {
        show: showPoseGuidance,
        message: poseGuidanceMessage,
        type: poseGuidanceType,
        direction: getGuidanceDirection(pose),
        nosePosition: getNosePosition(landmarks),
      };

      dispatch('faceDetected', {
        landmarks,
        pose,
        stable: stablePosition,
        progress,
        guidance: guidanceInfo,
      });
    } else {
      // No face detected
      // console.log('‚ùå No face detected'); // „É≠„Ç∞ÂâäÈô§
      handleNoFaceDetected();
    }

    drawUIOverlays();
    canvasCtx.restore();
  }

  function drawFaceMesh(landmarks: any) {
    if (!canvasCtx) return;

    drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, {
      color: '#C0C0C070',
      lineWidth: 1,
    });
    drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, {
      color: '#FF3030',
    });
    drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE, {
      color: '#30FF30',
    });
    drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL, {
      color: '#E0E0E0',
    });
    drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS, {
      color: '#E0E0E0',
    });
  }

  function handleNoFaceDetected() {
    faceDetectionCount = 0;

    if (faceDetected) {
      faceDetected = false;
      faceDetectionStartTime = null;
    }

    stablePosition = false;
    stableStartTime = null;
    progress = 0;

    // Clear pose guidance in CAMERA_STARTUP mode
    if (currentMode === CaptureMode?.CAMERA_STARTUP) {
      showPoseGuidance = false;
      poseGuidanceMessage = '';
    }

    // „Éá„Ç∂„Ç§„É≥„Å´„Å™„ÅÑ„Åü„ÇÅ„Çπ„ÉÜ„Éº„Çø„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„ÅØÈÄÅ‰ø°„Åó„Å™„ÅÑ

    dispatch('faceDetected', {
      landmarks: null,
      pose: null,
      stable: false,
      progress: 0,
    });

    showPoseGuidance = false;
    lastGuidanceMessage = '';
  }

  function calculateFaceSize(landmarks: any): number {
    try {
      // È°î„ÅÆÂ¢ÉÁïå„ÇíË®àÁÆó
      let minX = 1,
        maxX = 0,
        minY = 1,
        maxY = 0;

      // È°î„ÅÆËº™ÈÉ≠„Éù„Ç§„É≥„Éà„Çí‰ΩøÁî®„Åó„Å¶Â¢ÉÁïå„ÇíË®àÁÆó
      const faceContourIndices = [
        10, 151, 9, 8, 168, 6, 197, 195, 5, 4, 1, 19, 94, 125, 142, 36, 205,
        206, 207, 213, 192, 147, 187, 207, 206, 205, 36, 142, 125, 94, 19, 1, 4,
        5, 195, 197, 6, 168, 8, 9, 151, 10,
      ];

      for (const index of faceContourIndices) {
        if (landmarks[index]) {
          minX = Math.min(minX, landmarks[index].x);
          maxX = Math.max(maxX, landmarks[index].x);
          minY = Math.min(minY, landmarks[index].y);
          maxY = Math.max(maxY, landmarks[index].y);
        }
      }

      // È°î„ÅÆ„Çµ„Ç§„Ç∫„ÇíË®àÁÆóÔºàÁîªÂÉè„Å´ÂØæ„Åô„ÇãÁõ∏ÂØæ„Çµ„Ç§„Ç∫Ôºâ
      const faceWidth = maxX - minX;
      const faceHeight = maxY - minY;
      const faceSize = Math.sqrt(
        faceWidth * faceWidth + faceHeight * faceHeight
      );

      return faceSize;
    } catch (error) {
      console.warn('Face size calculation error:', error);
      return 0;
    }
  }

  function calculatePose(landmarks: any) {
    // PHPÁâà„Å®ÂÆåÂÖ®„Å´Âêå„ÅòÂßøÂã¢Ë®àÁÆó„É≠„Ç∏„ÉÉ„ÇØ
    try {
      // ÁâπÂæ¥ÁÇπ„ÅÆÂèñÂæóÔºàPHP„Å®Âêå„Åò„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÔºâ
      const nose = landmarks[1];
      const leftEye = landmarks[33];
      const rightEye = landmarks[263];
      const leftMouth = landmarks[61];
      const rightMouth = landmarks[291];

      if (!nose || !leftEye || !rightEye || !leftMouth || !rightMouth) {
        throw new Error('Required landmarks not found');
      }

      // „É≠„Éº„É´ÔºàZËª∏ÂõûËª¢Ôºâ- ÁõÆ„ÅÆÂÇæ„Åç - „Éü„É©„Éº„É™„É≥„Ç∞ÂØæÂøú
      const eyeDiffY = rightEye.y - leftEye.y;
      const eyeDiffX = rightEye.x - leftEye.x;
      const roll = (-Math.atan2(eyeDiffY, eyeDiffX) * 180) / Math.PI;

      // „Éî„ÉÉ„ÉÅÔºàXËª∏ÂõûËª¢Ôºâ- Á∏¶ÊñπÂêë„ÅÆÂÇæ„Åç - ‰øÆÊ≠£Áâà
      const eyeCenter = {
        y: (leftEye.y + rightEye.y) / 2,
        z: (leftEye.z + rightEye.z) / 2,
      };

      // Èºª„Å®ÁõÆ„ÅÆ‰∏≠ÂøÉ„ÅÆ‰ΩçÁΩÆÈñ¢‰øÇ
      const eyeNoseY = eyeCenter.y - nose.y;
      const eyeNoseZ = eyeCenter.z - nose.z;

      // ËßíÂ∫¶Ë®àÁÆó - Á¨¶Âè∑„Å®ÂºïÊï∞„ÇíË™øÊï¥
      let rawPitch = (-Math.atan2(eyeNoseZ, eyeNoseY) * 180) / Math.PI;

      // 180Â∫¶ÂïèÈ°å„ÅÆËß£Ê±∫
      if (rawPitch > 90) {
        rawPitch = rawPitch - 180;
      } else if (rawPitch < -90) {
        rawPitch = rawPitch + 180;
      }

      // ÊúÄÁµÇÁöÑ„Å™„Éî„ÉÉ„ÉÅÂÄ§Ôºà„Éá„Éê„Ç§„ÇπÂà•„Ç™„Éï„Çª„ÉÉ„ÉàÔºâ
      const screenWidth = window.innerWidth;
      let pitch;
      if (screenWidth <= 480) {
        // iPhone: +30Â∫¶
        pitch = rawPitch - 65 + 30;
      } else if (screenWidth <= 1024) {
        // iPad: +10Â∫¶ÔºàÂÖÉ„ÅÆÈáçË¶Å„Å™Ë™øÊï¥Ôºâ
        pitch = rawPitch - 65 + 10;
      } else {
        // PC: „Ç™„Éï„Çª„ÉÉ„Éà„Å™„Åó
        pitch = rawPitch - 35;
      }

      // „É®„ÉºÔºàYËª∏ÂõûËª¢Ôºâ- Ê®™ÊñπÂêë„ÅÆÂêë„Åç
      const eyeMidPoint = {
        x: (leftEye.x + rightEye.x) / 2,
      };
      const noseMidOffset = eyeMidPoint.x - nose.x;
      const yaw = noseMidOffset * 500;

      // È°î„ÅÆ„Çµ„Ç§„Ç∫„ÇíË®àÁÆó
      const faceSize = calculateFaceSize(landmarks);

      // Ë∑ùÈõ¢„Å®ÂìÅË≥™„ÅÆË®àÁÆó
      const eyeDistance = Math.sqrt(eyeDiffX * eyeDiffX + eyeDiffY * eyeDiffY);
      const distance = Math.max(0.5, Math.min(2.0, 1.0 / eyeDistance));
      const quality = Math.max(0.0, Math.min(1.0, faceSize * 2));

      const result = {
        roll: Math.round(roll * 10) / 10,
        pitch: Math.round(pitch * 10) / 10,
        yaw: Math.round(yaw * 10) / 10,
        distance: Math.round(distance * 100) / 100,
        quality: Math.round(quality * 100) / 100,
        faceSize: Math.round(faceSize * 1000) / 1000,
      };

      return result;
    } catch (error) {
      console.warn('Pose calculation error:', error);
      return {
        roll: 0,
        pitch: 0,
        yaw: 0,
        distance: 1.0,
        quality: 0.0,
        faceSize: 0.0,
      };
    }
  }

  function updateStability(pose: any) {
    const now = performance.now();

    // PHPÁâà„Å®Âêå„ÅòÂé≥„Åó„ÅÑÊù°‰ª∂
    const isGoodPose =
      Math.abs(pose.roll) < THRESHOLDS.roll &&
      Math.abs(pose.pitch) < THRESHOLDS.pitch &&
      Math.abs(pose.yaw) < THRESHOLDS.yaw &&
      pose.quality >= MIN_FACE_QUALITY &&
      pose.faceSize >= MIN_FACE_SIZE;

    // ÂßøÂã¢ÂÆâÂÆöÊÄß„ÉÅ„Çß„ÉÉ„ÇØ„ÅÆ„É≠„Ç∞„ÅØÂâäÈô§ÔºàÂøÖË¶ÅÊôÇ„ÅÆ„ÅøÊúâÂäπÂåñÔºâ
    // console.log('üéØ Pose stability check:', { roll: pose.roll.toFixed(1), pitch: pose.pitch.toFixed(1), yaw: pose.yaw.toFixed(1), isGoodPose, progress: progress.toFixed(1) });

    if (isGoodPose) {
      if (!stablePosition) {
        stablePosition = true;
        stableStartTime = now;
        showPoseGuidance = true;
        poseGuidanceMessage = 'ËâØ„ÅÑÂßøÂã¢„Åß„ÅôÔºÅ‰øùÊåÅ„Åó„Å¶„Åè„Å†„Åï„ÅÑ';
        poseGuidanceType = 'success';
        console.log('‚úÖ Stable position achieved!');

        // ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏„ÅØ2ÁßíÂæå„Å´ÈùûË°®Á§∫„Å´„Åô„Çã
        setTimeout(() => {
          if (stablePosition) {
            showPoseGuidance = false;
          }
        }, 2000);
      }

      if (stableStartTime) {
        const elapsed = (now - stableStartTime) / 1000;
        // „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„ÇíÂßøÂã¢ÂÆâÂÆöÂæå„ÅÆËá™ÂãïÊíÆÂΩ±ÂæÖÊ©üÊôÇÈñìÔºàFACE_DETECTION_DELAYÔºâ„Å´Âêà„Çè„Åõ„Çã
        progress = Math.min((elapsed / FACE_DETECTION_DELAY) * 100, 100);

        if (progress >= 100) {
          console.log('üéâ Auto capture countdown completed!');
        }
      }
    } else {
      if (stablePosition) {
        console.log('‚ùå Lost stable position');
      }
      stablePosition = false;
      stableStartTime = null;
      progress = 0;

      // Guidance messages
      if (now - lastGuidanceUpdate > GUIDANCE_UPDATE_INTERVAL) {
        updatePoseGuidance(pose);
        lastGuidanceUpdate = now;
      }
    }
  }

  function getGuidanceDirection(pose: any) {
    if (!pose) return null;

    // È°î„ÅÆÂìÅË≥™„Åå‰Ωé„ÅÑÂ†¥Âêà„ÅØÁü¢Âç∞„ÇíË°®Á§∫„Åó„Å™„ÅÑ
    if (pose.quality < MIN_FACE_QUALITY) {
      return null;
    }

    // ÂßøÂã¢„Å´Âü∫„Å•„ÅÑ„Å¶Áü¢Âç∞„ÅÆÊñπÂêë„ÇíÊ±∫ÂÆö
    if (Math.abs(pose.roll) >= THRESHOLDS.roll) {
      return pose.roll > 0 ? 'tilt-right' : 'tilt-left';
    } else if (Math.abs(pose.pitch) >= THRESHOLDS.pitch) {
      return pose.pitch > 0 ? 'look-down' : 'look-up';
    } else if (Math.abs(pose.yaw) >= THRESHOLDS.yaw) {
      return pose.yaw > 0 ? 'turn-right' : 'turn-left';
    }
    return null;
  }

  // PHP„Å®Âêå„ÅòÈºª„ÅÆ‰ΩçÁΩÆË®àÁÆóÔºàÂÆåÂÖ®ÁßªÊ§çÁâàÔºâ
  function getNosePosition(landmarks: any) {
    if (
      !landmarks ||
      !canvasElement ||
      currentVideoWidth === 0 ||
      currentVideoHeight === 0
    ) {
      // Debug: Log why getNosePosition is returning null
      if (Math.random() < 0.1) {
        // 10% chance to avoid spam
        console.log('üîç getNosePosition returning null:', {
          hasLandmarks: !!landmarks,
          hasCanvasElement: !!canvasElement,
          currentVideoWidth,
          currentVideoHeight,
        });
      }
      return null;
    }

    // Èºª„ÅÆÂÖàÁ´Ø„ÅÆ„É©„É≥„Éâ„Éû„Éº„ÇØÔºà„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ1Ôºâ
    const nose = landmarks[1];
    if (!nose) return null;

    // onResultsÈñ¢Êï∞„Å®Âêå„Åò„Ç¢„Çπ„Éö„ÇØ„ÉàÊØîË®àÁÆó„Çí‰ΩøÁî®
    const videoWidth = currentVideoWidth;
    const videoHeight = currentVideoHeight;
    const canvasWidth = canvasElement.width;
    const canvasHeight = canvasElement.height;

    const videoAspect = videoWidth / videoHeight;
    const canvasAspect = canvasWidth / canvasHeight;

    let drawWidth, drawHeight, drawX, drawY;

    if (videoAspect > canvasAspect) {
      // Video is wider - fit to canvas height
      drawHeight = canvasHeight;
      drawWidth = drawHeight * videoAspect;
      drawX = (canvasWidth - drawWidth) / 2;
      drawY = 0;
    } else {
      // Video is taller - fit to canvas width
      drawWidth = canvasWidth;
      drawHeight = drawWidth / videoAspect;
      drawX = 0;
      drawY = (canvasHeight - drawHeight) / 2;
    }

    // ÂÆüÈöõ„ÅÆÊèèÁîªÈ†òÂüüÂÜÖ„Åß„ÅÆÂ∫ßÊ®ôË®àÁÆó
    const noseX = (1 - nose.x) * drawWidth + drawX;
    const noseY = nose.y * drawHeight + drawY;

    // Ë°®Á§∫„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Å¶„Çπ„Ç±„Éº„É™„É≥„Ç∞
    const canvasRect = canvasElement.getBoundingClientRect();
    const scaleX = canvasRect.width / canvasElement.width;
    const scaleY = canvasRect.height / canvasElement.height;

    const displayX = noseX * scaleX;
    const displayY = noseY * scaleY;

    // Debug: Log successful nose position calculation
    if (Math.random() < 0.05) {
      // 5% chance to avoid spam
      console.log('üéØ Nose position calculated:', {
        nose: { x: nose.x, y: nose.y },
        videoAspect: videoAspect.toFixed(2),
        canvasAspect: canvasAspect.toFixed(2),
        drawRegion: { drawX, drawY, drawWidth, drawHeight },
        canvasCoords: { noseX, noseY },
        displayCoords: { displayX, displayY },
      });
    }

    return { x: displayX, y: displayY };
  }

  function updatePoseGuidance(pose: any) {
    // Don't show pose guidance in CAMERA_STARTUP mode
    if (currentMode === CaptureMode?.CAMERA_STARTUP) {
      return;
    }

    let message = '';
    let type = 'warning';

    // „Çà„ÇäË©≥Á¥∞„ÅßË¶™Âàá„Å™„Ç¨„Ç§„ÉÄ„É≥„Çπ„É°„ÉÉ„Çª„Éº„Ç∏ÔºàPHPÁâà„Å®Âêå„ÅòÂÑ™ÂÖàÈ†Ü‰ΩçÔºâ
    if (pose.faceSize < MIN_FACE_SIZE) {
      message = '„Ç´„É°„É©„Å´Ëøë„Å•„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑÔºàÈ°î„ÅåÂ∞è„Åï„Åô„Åé„Åæ„ÅôÔºâ';
      type = 'error';
    } else if (pose.quality < MIN_FACE_QUALITY) {
      message = 'È°îÂÖ®‰Ωì„Çí„Ç´„É°„É©„Å´Âêë„Åë„Å¶„Åè„Å†„Åï„ÅÑ';
      type = 'error';
    } else if (Math.abs(pose.roll) >= THRESHOLDS.roll) {
      message =
        pose.roll > 0
          ? 'È†≠„ÇíÂ∑¶„Å´Â∞ë„ÅóÂÇæ„Åë„Å¶„Åè„Å†„Åï„ÅÑ'
          : 'È†≠„ÇíÂè≥„Å´Â∞ë„ÅóÂÇæ„Åë„Å¶„Åè„Å†„Åï„ÅÑ';
    } else if (Math.abs(pose.pitch) >= THRESHOLDS.pitch) {
      message =
        pose.pitch > 0
          ? 'È°î„ÇíÂ∞ë„Åó‰∏ä„Å´Âêë„Åë„Å¶„Åè„Å†„Åï„ÅÑ'
          : 'È°î„ÇíÂ∞ë„Åó‰∏ã„Å´Âêë„Åë„Å¶„Åè„Å†„Åï„ÅÑ';
    } else if (Math.abs(pose.yaw) >= THRESHOLDS.yaw) {
      message =
        pose.yaw > 0 ? 'È°î„ÇíÂè≥„Å´Âêë„Åë„Å¶„Åè„Å†„Åï„ÅÑ' : 'È°î„ÇíÂ∑¶„Å´Âêë„Åë„Å¶„Åè„Å†„Åï„ÅÑ';
    } else {
      message = 'ÂÆåÁíß„Å™ÂßøÂã¢„Åß„ÅôÔºÅ„Åì„ÅÆÁä∂ÊÖã„Çí‰øùÊåÅ„Åó„Å¶„Åè„Å†„Åï„ÅÑ';
      type = 'success';
    }

    if (message) {
      poseGuidanceMessage = message;
      poseGuidanceType = type;
      showPoseGuidance = true;
      lastGuidanceMessage = message;

      // ÂßøÂã¢„ÅåÊÇ™„ÅÑÈñì„ÅØÁ∂ôÁ∂öÁöÑ„Å´Ë°®Á§∫ÔºàÂêå„Åò„É°„ÉÉ„Çª„Éº„Ç∏„Åß„ÇÇÁ∂ôÁ∂öË°®Á§∫Ôºâ
    }
  }

  // PHP„Å®Âêå„Åò„Éî„Éé„Ç≠„Ç™Ê£íÔºàÈùí„ÅÑËª∏ÔºâÊèèÁîªÊ©üËÉΩ
  function drawPoseAxes(landmarks: any) {
    if (!canvasCtx || !canvasElement) return;

    // ÁèæÂú®„ÅÆÂßøÂã¢„ÇíË®àÁÆó
    const pose = calculatePose(landmarks);

    // Èè°ÂÉèË°®Á§∫„Å´ÂØæÂøú„Åô„Çã„Åü„ÇÅ„ÅÆÂ§âÊèõ
    canvasCtx.scale(-1, 1);
    canvasCtx.translate(-canvasElement.width, 0);

    const nose = landmarks[1];
    const scale = 0.2; // Ëª∏„ÅÆÈï∑„Åï

    // Â∫ßÊ®ôËª∏„ÅÆÊèèÁîªÔºàÈºª„Åã„Çâ‰º∏„Å≥„ÇãÈùí„ÅÑËª∏Ôºâ
    // „Éü„É©„Éº„É™„É≥„Ç∞ÊôÇ„ÅÆÂ∫ßÊ®ô„Å´Â§âÊèõ
    const noseX = (1 - nose.x) * canvasElement.width;
    const noseY = nose.y * canvasElement.height;

    // ZËª∏ÔºàÈùíÔºâ- „É®„ÉºÔºàÈ°î„ÅÆÂêë„ÅçÔºâ„Å´Âøú„Åò„Å¶ÊñπÂêë„ÅåÂ§â„Çè„Çã
    const zAxisX =
      noseX +
      Math.sin((pose.yaw * Math.PI) / 180) * scale * canvasElement.width;

    // ÂÜÜÊü±„ÅÆÊèèÁîªÔºàZËª∏Ôºâ
    const cylinderWidth = 12; // ÂÜÜÊü±„ÅÆÂπÖ

    // „Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„ÅßÂÜÜÊü±ÂäπÊûú„Çí‰ΩúÊàê
    const gradient = canvasCtx.createLinearGradient(
      noseX,
      noseY,
      zAxisX,
      noseY
    );
    gradient.addColorStop(0, 'rgba(0, 0, 255, 1)'); // ÊøÉ„ÅÑÈùíÔºàÂßãÁÇπÔºâ
    gradient.addColorStop(1, 'rgba(100, 100, 255, 1)'); // Êòé„Çã„ÅÑÈùíÔºàÁµÇÁÇπÔºâ

    // ÂÜÜÊü±„ÅÆÊú¨‰Ωì„ÇíÊèèÁîª
    canvasCtx.beginPath();
    canvasCtx.moveTo(noseX, noseY - cylinderWidth / 2);
    canvasCtx.lineTo(zAxisX, noseY - cylinderWidth / 2);
    canvasCtx.lineTo(zAxisX, noseY + cylinderWidth / 2);
    canvasCtx.lineTo(noseX, noseY + cylinderWidth / 2);
    canvasCtx.closePath();
    canvasCtx.fillStyle = gradient;
    canvasCtx.fill();

    // ÁµÇÁÇπ„ÅÆÂÜÜ„ÇíÊèèÁîª
    canvasCtx.beginPath();
    canvasCtx.arc(zAxisX, noseY, cylinderWidth / 2, 0, Math.PI * 2);
    canvasCtx.fillStyle = 'rgba(100, 100, 255, 1)';
    canvasCtx.fill();

    // ÂßãÁÇπ„ÅÆÂÜÜ„ÇíÊèèÁîª
    canvasCtx.beginPath();
    canvasCtx.arc(noseX, noseY, cylinderWidth / 2, 0, Math.PI * 2);
    canvasCtx.fillStyle = 'rgba(0, 0, 255, 1)';
    canvasCtx.fill();
  }

  function checkAutoCapture() {
    if (!faceDetected || !stableStartTime) return;

    // ÂßøÂã¢„ÅåÂÆâÂÆö„Åó„Å¶„Åã„Çâ„ÅÆÁµåÈÅéÊôÇÈñì„ÇíË®àÁÆó
    const elapsed = (performance.now() - stableStartTime) / 1000;

    console.log('Auto capture check:', {
      elapsed: elapsed.toFixed(2),
      required: FACE_DETECTION_DELAY,
      stablePosition,
      progress: progress.toFixed(1),
      currentMode,
    });

    // ÂßøÂã¢„ÅåÂÆâÂÆö„Åó„Å¶„Åã„Çâ3ÁßíÁµåÈÅé„ÅßÊíÆÂΩ±
    if (elapsed >= FACE_DETECTION_DELAY && stablePosition && progress >= 100) {
      console.log('üéØ Auto capture triggered!');
      dispatch('autoCapture', { landmarks: faceLandmarks });

      // Reset detection to prevent multiple captures
      faceDetectionStartTime = null;
      faceDetected = false;
      stablePosition = false;
      stableStartTime = null;
      progress = 0;
    }
  }

  function drawUIOverlays() {
    if (!canvasCtx || !canvasElement) return;

    // Save the current transformation matrix
    canvasCtx.save();

    // „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„ÅÆ„ÅøÊèèÁîªÔºàÁôΩ„ÅÑÂÜÜ„ÅØCSS„ÅßË°®Á§∫Ôºâ
    if (
      currentMode !== CaptureMode?.CAMERA_STARTUP &&
      faceDetected &&
      stablePosition &&
      progress > 0
    ) {
      const centerX = canvasElement.width / 2;
      const centerY = canvasElement.height / 2;
      // CSS „ÅÆ„Éû„Çπ„ÇØÂÜÜ„Å®Âêå„Åò„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„ÇãÔºà„É¨„Çπ„Éù„É≥„Ç∑„ÉñÂØæÂøúÔºâ
      const circleSize = Math.min(300, window.innerWidth * 0.5);
      const radius = circleSize / 2 - 10; // „Éû„Çπ„ÇØÂÜÜ„ÅÆÂÜÖÂÅ¥„Å´„Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„ÇíÊèèÁîª

      const progressAngle = (progress / 100) * 2 * Math.PI - Math.PI / 2;

      canvasCtx.beginPath();
      canvasCtx.arc(centerX, centerY, radius, -Math.PI / 2, progressAngle);
      canvasCtx.strokeStyle = progress >= 100 ? '#4CAF50' : '#FFA500';
      canvasCtx.lineWidth = 8;
      canvasCtx.stroke();
    }

    // „Éî„Éé„Ç≠„Ç™Ê£íÔºàÈùí„ÅÑËª∏Ôºâ„ÅÆÊèèÁîª - PHP„Å®Âêå„ÅòÂÆüË£Ö
    if (faceLandmarks && faceDetected) {
      drawPoseAxes(faceLandmarks);
    }

    // Restore the transformation matrix
    canvasCtx.restore();
  }

  function cleanup() {
    console.log('üîÑ Cleaning up camera and face detection resources');

    // Stop camera but don't destroy faceMesh (for reuse)
    if (camera) {
      camera.stop();
      camera = null;
    }

    // Stop video stream
    if (videoElement && videoElement.srcObject) {
      const stream = videoElement.srcObject as MediaStream;
      stream.getTracks().forEach(track => {
        track.stop();
        console.log('üõë Stopped camera track:', track.kind);
      });
      videoElement.srcObject = null;
    }

    // Reset detection state
    faceDetected = false;
    faceDetectionCount = 0;
    faceDetectionStartTime = null;
    stablePosition = false;
    stableStartTime = null;
    progress = 0;
    isStartingCamera = false;

    console.log('‚úÖ Camera cleanup completed (faceMesh preserved for reuse)');
  }

  // Complete cleanup function for component destruction
  function completeCleanup() {
    console.log('üóëÔ∏è Complete cleanup - destroying all resources');
    cleanup();

    if (faceMesh) {
      faceMesh.close();
      faceMesh = null;
    }
  }

  // Export cleanup functions for external use
  export { cleanup, completeCleanup };

  // Export function to get current face landmarks
  export function getCurrentFaceLandmarks() {
    return faceLandmarks;
  }

  // Export startCamera function for external use
  export { startCamera };

  // „Ç≠„É£„É≥„Éê„ÇπÂêåÊúüÊ©üËÉΩ„ÅØÂâäÈô§

  // Export guidance state
  export { showPoseGuidance, poseGuidanceMessage, poseGuidanceType };
</script>

<!-- This component doesn't render anything directly -->
<!-- It only handles face detection logic and dispatches events -->
